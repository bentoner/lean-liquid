import algebra.homology.homological_complex
import category_theory.abelian.exact
import for_mathlib.homological_complex_shift
import for_mathlib.split_exact
import category_theory.triangulated.rotate
import algebra.homology.homotopy_category
import algebra.homology.additive
import for_mathlib.homological_complex_abelian

noncomputable theory

universes v u

open_locale classical

open category_theory category_theory.limits

namespace homological_complex

variables {V : Type u} [category.{v} V] [abelian V]
variables (A B C : cochain_complex V ‚Ñ§) (f : A ‚ü∂ B) (g : B ‚ü∂ C)

@[simp, reassoc]
lemma homotopy.comp_X_eq_to_iso {X Y : cochain_complex V ‚Ñ§} {f g : X ‚ü∂ Y} (h : homotopy f g)
  (i : ‚Ñ§) {j k : ‚Ñ§} (e : j = k) : h.hom i j ‚â´ (Y.X_eq_to_iso e).hom = h.hom i k :=
by { subst e, simp }

@[simp, reassoc]
lemma homotopy.X_eq_to_iso_comp {X Y : cochain_complex V ‚Ñ§} {f g : X ‚ü∂ Y} (h : homotopy f g)
  {i j : ‚Ñ§} (e : i = j) (k : ‚Ñ§) : (X.X_eq_to_iso e).hom ‚â´ h.hom j k = h.hom i k :=
by { subst e, simp }


def cone.X : ‚Ñ§ ‚Üí V := Œª i, A.X (i + 1) ‚äû B.X i

variables {A B C}

def cone.d : Œ† (i j : ‚Ñ§), cone.X A B i ‚ü∂ cone.X A B j :=
Œª i j, if hij : i + 1 = j then biprod.lift
  (biprod.desc (-A.d _ _)                         0        )
  (biprod.desc (f.f _ ‚â´ (B.X_eq_to_iso hij).hom) (B.d _ _))
else 0

/-- The mapping cone of a morphism `f : A ‚Üí B` of homological complexes. -/
def cone : cochain_complex V ‚Ñ§ :=
{ X := cone.X A B,
  d := cone.d f,
  shape' := Œª i j hij, dif_neg hij,
  d_comp_d' := Œª i j k (hij : _ = _) (hjk : _ = _),
  begin
    substs hij hjk,
    ext; simp [cone.d],
  end }

@[simp]
lemma cone_X (i : ‚Ñ§) : (cone f).X i = (A.X (i + 1) ‚äû B.X i) := rfl

@[simp]
lemma cone_d : (cone f).d = cone.d f := rfl

def cone.in : B ‚ü∂ cone f :=
{ f := Œª i, biprod.inr,
  comm' := Œª i j hij,
  begin
    dsimp [cone_d, cone.d], dsimp at hij, rw [dif_pos hij],
    ext;
    simp only [comp_zero, category.assoc, category.comp_id,
      biprod.inr_desc, biprod.inr_fst, biprod.lift_fst, biprod.inr_snd, biprod.lift_snd],
  end }

local attribute [instance] endofunctor_monoidal_category discrete.add_monoidal

def cone.out : cone f ‚ü∂ A‚ü¶(1 : ‚Ñ§)‚üß :=
{ f := Œª i, biprod.fst,
  comm' := Œª i j (hij : _ = _),
  begin
    subst hij,
    dsimp [cone_d, cone.d],
    ext; simp,
  end }

@[simps]
def cone.triangle : triangulated.triangle (cochain_complex V ‚Ñ§) :=
{ obj‚ÇÅ := A,
  obj‚ÇÇ := B,
  obj‚ÇÉ := cone f,
  mor‚ÇÅ := f,
  mor‚ÇÇ := cone.in f,
  mor‚ÇÉ := cone.out f }

variable (V)

@[simps]
def _root_.homotopy_category.lift_triangle :
  triangulated.triangle (cochain_complex V ‚Ñ§) ‚•§
    triangulated.triangle (homotopy_category V (complex_shape.up ‚Ñ§)) :=
{ obj := Œª t, triangulated.triangle.mk _
    ((homotopy_category.quotient _ _).map t.mor‚ÇÅ)
    ((homotopy_category.quotient _ _).map t.mor‚ÇÇ)
    ((homotopy_category.quotient _ _).map t.mor‚ÇÉ),
  map := Œª t t' f,
  { hom‚ÇÅ := (homotopy_category.quotient _ _).map f.hom‚ÇÅ,
    hom‚ÇÇ := (homotopy_category.quotient _ _).map f.hom‚ÇÇ,
    hom‚ÇÉ := (homotopy_category.quotient _ _).map f.hom‚ÇÉ,
    comm‚ÇÅ' := by { dsimp, rw [‚Üê functor.map_comp, ‚Üê functor.map_comp, f.comm‚ÇÅ] },
    comm‚ÇÇ' := by { dsimp, rw [‚Üê functor.map_comp, ‚Üê functor.map_comp, f.comm‚ÇÇ] },
    comm‚ÇÉ' := by { dsimp, rw [‚Üê functor.map_comp, ‚Üê functor.map_comp, f.comm‚ÇÉ] } },
  map_id' := Œª X, by { ext; exact category_theory.functor.map_id _ _  },
  map_comp' := Œª X Y Z f g, by { ext; exact category_theory.functor.map_comp _ _ _ } }

variable {V}

@[simps]
def cone.triangle‚Çï : triangulated.triangle (homotopy_category V (complex_shape.up ‚Ñ§)) :=
(homotopy_category.lift_triangle _).obj (cone.triangle f)

section cone_functorial

variables {f} {A' B' : cochain_complex V ‚Ñ§} {f' : A' ‚ü∂ B'} {i‚ÇÅ : A ‚ü∂ A'} {i‚ÇÇ : B ‚ü∂ B'}
variables (comm : homotopy (f ‚â´ i‚ÇÇ) (i‚ÇÅ ‚â´ f'))

include comm

def cone.map : cone f ‚ü∂ cone f' :=
{ f := Œª i, biprod.lift
  (biprod.desc (i‚ÇÅ.f _) 0)
  (biprod.desc (comm.hom _ _) (i‚ÇÇ.f _)),
  comm' := Œª i j r,
  begin
    change i+1 = j at r,
    dsimp [cone_d, cone.d],
    simp_rw dif_pos r,
    apply category_theory.limits.biprod.hom_ext;
      simp only [biprod.lift_desc, add_zero, preadditive.comp_neg, category.assoc,
        comp_zero, biprod.lift_fst, biprod.lift_snd]; ext,
    { simp },
    { simp },
    { simp only [X_eq_to_iso_f, preadditive.comp_add, biprod.inl_desc_assoc, category.assoc,
        preadditive.neg_comp],
      have := comm.comm (i+1),
      dsimp at this,
      rw [reassoc_of this],
      subst r,
      simpa [prev_d, d_next, ‚Üê add_assoc] using add_comm _ _ },
    { simp }
  end }

@[simp, reassoc]
lemma cone.in_map : cone.in f ‚â´ cone.map comm = i‚ÇÇ ‚â´ cone.in f' :=
by ext; { dsimp [cone.map, cone.in], simp }

@[simp, reassoc]
lemma cone.map_out : cone.map comm ‚â´ cone.out f' = cone.out f ‚â´ i‚ÇÅ‚ü¶(1 : ‚Ñ§)‚üß' :=
by ext; { dsimp [cone.map, cone.out], simp }

omit comm

-- I suppose this is not true?
-- def cone.map_homotopy_of_homotopy' (comm' : homotopy (f ‚â´ i‚ÇÇ) (i‚ÇÅ ‚â´ f')) :
--   homotopy (cone.map comm) (cone.map comm') := by admit

@[simps]
def cone.triangle‚Çï_map : cone.triangle‚Çï f ‚ü∂ cone.triangle‚Çï f' :=
{ hom‚ÇÅ := (homotopy_category.quotient _ _).map i‚ÇÅ,
  hom‚ÇÇ := (homotopy_category.quotient _ _).map i‚ÇÇ,
  hom‚ÇÉ := (homotopy_category.quotient _ _).map $ cone.map comm,
  comm‚ÇÅ' := by { dsimp [cone.triangle‚Çï], simp_rw ‚Üê functor.map_comp,
    exact homotopy_category.eq_of_homotopy _ _ comm },
  comm‚ÇÇ' := by { dsimp [cone.triangle‚Çï], simp_rw ‚Üê functor.map_comp, simp },
  comm‚ÇÉ' := by { dsimp [cone.triangle‚Çï], simp_rw ‚Üê functor.map_comp, simp } }

@[simps]
def cone.triangle_map (h : f ‚â´ i‚ÇÇ = i‚ÇÅ ‚â´ f') : cone.triangle f ‚ü∂ cone.triangle f' :=
{ hom‚ÇÅ := i‚ÇÅ,
  hom‚ÇÇ := i‚ÇÇ,
  hom‚ÇÉ := cone.map (homotopy.of_eq h),
  comm‚ÇÅ' := by simpa [cone.triangle],
  comm‚ÇÇ' := by { dsimp [cone.triangle], simp },
  comm‚ÇÉ' := by { dsimp [cone.triangle], simp } }

@[simp]
lemma cone.map_id (f : A ‚ü∂ B) :
  cone.map (homotopy.of_eq $ (category.comp_id f).trans (category.id_comp f).symm) = ùüô _ :=
by { ext; dsimp [cone.map, cone, cone.X]; simp }

@[simp]
lemma cone.triangle_map_id (f : A ‚ü∂ B) :
  cone.triangle_map ((category.comp_id f).trans (category.id_comp f).symm) = ùüô _ :=
by { ext; dsimp [cone.map, cone, cone.X]; simp }


def cone.triangle_functorial :
  arrow (cochain_complex V ‚Ñ§) ‚•§ triangulated.triangle (cochain_complex V ‚Ñ§) :=
{ obj := Œª f, cone.triangle f.hom,
  map := Œª f g c, cone.triangle_map c.w.symm,
  map_id' := Œª X, cone.triangle_map_id _,
  map_comp' := Œª X Y Z f g, by { ext; dsimp [cone.map, cone, cone.X]; simp } }

-- I suppose this is also not true?
-- def cone.triangle‚Çï_functorial :
--   arrow (homotopy_category V (complex_shape.up ‚Ñ§)) ‚•§
--     triangulated.triangle (homotopy_category V (complex_shape.up ‚Ñ§)) :=
-- { obj := Œª f, cone.triangle‚Çï f.hom.out,
--   map := Œª f g c, @cone.triangle‚Çï_map _ _ _ _ _ _ _ _ _ c.left.out c.right.out
--   begin
--     refine homotopy_category.homotopy_of_eq _ _ _,
--     simpa [-arrow.w] using c.w.symm
--   end,
--   map_id' := by admit,
--   map_comp' := sorry }

open_locale zero_object

instance : has_zero_object (cochain_complex V ‚Ñ§) := infer_instance

def cone_from_zero (A : cochain_complex V ‚Ñ§) : cone (0 : 0 ‚ü∂ A) ‚âÖ A :=
{ hom :=
  { f := Œª i, biprod.snd, comm' := by { introv r, ext, dsimp [cone.d] at *, simp [if_pos r] } },
  inv := cone.in _,
  inv_hom_id' := by { intros, ext, dsimp [cone.in], simp } }

def cone_to_zero (A : cochain_complex V ‚Ñ§) : cone (0 : A ‚ü∂ 0) ‚âÖ A‚ü¶(1 : ‚Ñ§)‚üß :=
{ hom := cone.out _,
  inv :=
    { f := Œª i, biprod.inl, comm' := by { introv r, ext, dsimp [cone.d] at *, simp [if_pos r] } },
  hom_inv_id' := by { intros, ext, dsimp [cone.out], simp },
  inv_hom_id' := by { intros, ext, dsimp [cone.out], simp } }

def cone.desc_of_null_homotopic (h : homotopy (f ‚â´ g) 0) : cone f ‚ü∂ C :=
cone.map (h.trans (homotopy.of_eq (comp_zero.symm : 0 = 0 ‚â´ 0))) ‚â´ (cone_from_zero _).hom

def cone.lift_of_null_homotopic (h : homotopy (f ‚â´ g) 0) : A ‚ü∂ cone g‚ü¶(-1 : ‚Ñ§)‚üß :=
(shift_shift_neg A (1 : ‚Ñ§)).inv ‚â´ (shift_functor _ (-1 : ‚Ñ§)).map ((cone_to_zero _).inv ‚â´
  cone.map (h.trans (homotopy.of_eq (comp_zero.symm : 0 = 0 ‚â´ 0))).symm)

@[simps]
def of_termwise_split_mono [H : ‚àÄ i, split_mono (f.f i)] : B ‚ü∂ B' :=
{ f := Œª i, i‚ÇÇ.f i - (H i).retraction ‚â´ comm.hom i (i-1) ‚â´ B'.d (i-1) i -
    B.d i (i+1) ‚â´ (H (i+1)).retraction ‚â´ comm.hom (i+1) i,
  comm' := Œª i j (r : i + 1 = j), by { subst r, simp only [d_comp_d, sub_zero, category.assoc,
    comp_zero, preadditive.comp_sub, hom.comm, preadditive.sub_comp, zero_comp, sub_right_inj,
    d_comp_d_assoc], congr; ring } }

@[simp, reassoc]
lemma of_termwise_split_mono_commutes [H : ‚àÄ i, split_mono (f.f i)] :
  f ‚â´ of_termwise_split_mono comm = i‚ÇÅ ‚â´ f' :=
begin
  ext i,
  dsimp,
  have : f.f i ‚â´ i‚ÇÇ.f i = A.d i (i + 1) ‚â´ comm.hom (i + 1) i + comm.hom i (i - 1) ‚â´
    B'.d (i - 1) i + i‚ÇÅ.f i ‚â´ f'.f i := by simpa [d_next, prev_d] using comm.comm i,
  simp only [hom.comm_assoc, preadditive.comp_sub, this],
  erw [split_mono.id_assoc, split_mono.id_assoc],
  simp [add_right_comm]
end

def of_termwise_split_mono_homotopy [H : ‚àÄ i, split_mono (f.f i)] :
  homotopy i‚ÇÇ (of_termwise_split_mono comm)  :=
{ hom := Œª i j, (H i).retraction ‚â´ comm.hom i j,
  zero' := Œª _ _ r, by rw [comm.zero _ _ r, comp_zero],
  comm := Œª i,
    by { simp [d_next, prev_d], abel } }

@[simps]
def of_termwise_split_epi [H : ‚àÄ i, split_epi (f'.f i)] : A ‚ü∂ A' :=
{ f := Œª i, i‚ÇÅ.f i + comm.hom i (i-1) ‚â´ (H (i-1)).section_ ‚â´ A'.d (i-1) i +
    A.d i (i+1) ‚â´ comm.hom (i+1) i ‚â´ (H i).section_,
  comm' := Œª i j (r : i + 1 = j), by { subst r, simp only [add_zero, d_comp_d, preadditive.comp_add,
    category.assoc, comp_zero, add_right_inj, hom.comm, zero_comp, preadditive.add_comp,
    d_comp_d_assoc], congr; ring } }

@[simp, reassoc]
lemma of_termwise_split_epi_commutes [H : ‚àÄ i, split_epi (f'.f i)] :
  of_termwise_split_epi comm ‚â´ f' = f ‚â´ i‚ÇÇ :=
begin
  ext i,
  dsimp,
  have : f.f i ‚â´ i‚ÇÇ.f i = A.d i (i + 1) ‚â´ comm.hom (i + 1) i + comm.hom i (i - 1) ‚â´
    B'.d (i - 1) i + i‚ÇÅ.f i ‚â´ f'.f i := by simpa [d_next, prev_d] using comm.comm i,
  simp only [this, category.assoc, preadditive.add_comp, ‚Üê f'.comm],
  erw [split_epi.id, split_epi.id_assoc],
  rw [add_comm, add_comm (i‚ÇÅ.f i ‚â´ f'.f i), ‚Üê add_assoc, category.comp_id]
end

def of_termwise_split_epi_homotopy [H : ‚àÄ i, split_epi (f'.f i)] :
  homotopy (of_termwise_split_epi comm) i‚ÇÅ :=
{ hom := Œª i j, comm.hom i j ‚â´ (H j).section_,
  zero' := Œª _ _ r, by rw [comm.zero _ _ r, zero_comp],
  comm := Œª i,
    by { simp [d_next, prev_d], abel } }

end cone_functorial

section termwise_split_mono_lift

@[simps]
def termwise_split_mono_lift (f : A ‚ü∂ B) : A ‚ü∂ biproduct B (cone (ùüô A)) :=
biproduct.lift f (cone.in _)

@[simps]
def termwise_split_mono_desc (f : A ‚ü∂ B) : biproduct B (cone (ùüô A)) ‚ü∂ B :=
biproduct.fst

@[simps]
def termwise_split_mono_section (f : A ‚ü∂ B) : B ‚ü∂ biproduct B (cone (ùüô A)) :=
biproduct.inl

@[simp, reassoc] lemma termwise_split_mono_section_desc (f : A ‚ü∂ B) :
  termwise_split_mono_section f ‚â´ termwise_split_mono_desc f = ùüô _ :=
by { ext, simp }
.
lemma termwise_split_mono_desc_section_aux (i : ‚Ñ§) :
  ùüô (B.X i ‚äû (A.X (i + 1) ‚äû A.X i)) = biprod.snd ‚â´ biprod.desc (ùüô (A.X (i + 1))) (A.d i (i + 1)) ‚â´
    biprod.inl ‚â´ biprod.inr + biprod.snd ‚â´ biprod.snd ‚â´
    (X_eq_to_iso A (sub_add_cancel i 1).symm).hom ‚â´ biprod.inl ‚â´ biprod.lift
    (biprod.desc (-A.d (i - 1 + 1) (i + 1)) 0) (biprod.desc (X_eq_to_iso A (sub_add_cancel i 1)).hom
    (A.d (i - 1) i)) ‚â´ biprod.inr + biprod.fst ‚â´ biprod.inl :=
begin
  ext1; simp only [zero_comp, preadditive.comp_add, zero_add, add_zero, biprod.inr_fst_assoc,
    biprod.inl_fst_assoc, biprod.inl_snd_assoc, biprod.inr_snd_assoc, category.comp_id],
  ext1, { simp },
  ext1, { simp only [add_zero, preadditive.add_comp, comp_zero, biprod.inr_fst, category.assoc] },
  ext1; simp,
end
.
def termwise_split_mono_desc_section (f : A ‚ü∂ B) :
  homotopy (ùüô _) (termwise_split_mono_desc f ‚â´ termwise_split_mono_section f) :=
{ hom := Œª i j, if h : i = j + 1 then
    biprod.snd ‚â´ biprod.snd ‚â´ (A.X_eq_to_iso h).hom ‚â´ biprod.inl ‚â´ biprod.inr else 0,
  zero' := Œª i j r, dif_neg (ne.symm r),
  comm := Œª i, by { dsimp,
    simpa [d_next, prev_d, cone.d] using termwise_split_mono_desc_section_aux i } }

instance (f : A ‚ü∂ B) (i : ‚Ñ§) : split_mono ((termwise_split_mono_lift f).f i) :=
{ retraction := biprod.snd ‚â´ biprod.snd, id' := by simp [cone.in] }

-- generalize to epi
@[simp]
def termwise_split_mono_lift_desc (f : A ‚ü∂ B) :
  termwise_split_mono_lift f ‚â´ termwise_split_mono_desc f = f :=
by { ext, simp }

/-- We will prove this is iso later -/
def from_termwise_split_mono_lift_triangle‚Çï :
  cone.triangle‚Çï (termwise_split_mono_lift f) ‚ü∂ cone.triangle‚Çï f :=
cone.triangle‚Çï_map
  (homotopy.of_eq ((termwise_split_mono_lift_desc f).trans (category.id_comp f).symm))

@[simps]
def termwise_split_mono_factor_homotopy_equiv : homotopy_equiv (biproduct B (cone (ùüô A))) B :=
{ hom := termwise_split_mono_desc f,
  inv := termwise_split_mono_section f,
  homotopy_hom_inv_id := (termwise_split_mono_desc_section f).symm,
  homotopy_inv_hom_id := homotopy.of_eq (termwise_split_mono_section_desc f) }

end termwise_split_mono_lift

section termwise_split_epi_lift

@[simps]
def termwise_split_epi_lift (f : A ‚ü∂ B) : A ‚ü∂ biproduct A (cone (ùüô (B‚ü¶(-1 : ‚Ñ§)‚üß))) :=
biproduct.inl

@[simps]
def termwise_split_epi_desc (f : A ‚ü∂ B) : biproduct A (cone (ùüô (B‚ü¶(-1 : ‚Ñ§)‚üß))) ‚ü∂ B :=
biproduct.desc f (cone.out _ ‚â´ (shift_neg_shift _ _).hom)

@[simps]
def termwise_split_epi_retraction (f : A ‚ü∂ B) : biproduct A (cone (ùüô (B‚ü¶(-1 : ‚Ñ§)‚üß))) ‚ü∂ A :=
biproduct.fst

@[simp, reassoc] lemma termwise_split_epi_lift_retraction (f : A ‚ü∂ B) :
  termwise_split_epi_lift f ‚â´ termwise_split_epi_retraction f = ùüô _ :=
by { ext, simp }

@[simp]
lemma X_eq_to_iso_shift (n i j : ‚Ñ§) (h : i = j) :
  X_eq_to_iso (A‚ü¶n‚üß) h = A.X_eq_to_iso (congr_arg _ h) := rfl

lemma termwise_split_epi_retraction_lift_aux (i : ‚Ñ§) :
  ùüô (A.X i ‚äû (B.X (i + 1 - 1) ‚äû B.X (i - 1))) = biprod.snd ‚â´ biprod.desc (ùüô _)
  (-B.d (i + -1) (i + 1 + -1)) ‚â´ ùüô _ ‚â´ biprod.inl ‚â´ biprod.inr + biprod.snd ‚â´ biprod.snd ‚â´
  ((B‚ü¶(-1 : ‚Ñ§)‚üß).X_eq_to_iso (sub_add_cancel _ _).symm).hom ‚â´ biprod.inl ‚â´ biprod.lift
  (biprod.desc (B.d (i - 1 + 1 + -1) (i + 1 + -1)) 0) (biprod.desc
  ((B‚ü¶(-1 : ‚Ñ§)‚üß).X_eq_to_iso $ sub_add_cancel _ _).hom (-B.d (i - 1 + -1) (i + -1))) ‚â´
  biprod.inr + biprod.fst ‚â´ biprod.inl :=
begin
  ext1; simp only [category.comp_id, add_zero, category.id_comp, preadditive.comp_add,
    biprod.inl_snd_assoc, zero_add, zero_comp, biprod.inl_fst_assoc, biprod.inr_fst_assoc,
    biprod.inr_snd_assoc],
  ext1, { simp },
  simp only [biprod.inr_desc_assoc, preadditive.neg_comp_assoc, X_eq_to_iso_shift,
    biprod.inr_snd_assoc, preadditive.comp_add, category.assoc, preadditive.neg_comp],
  ext1, { simp only [add_zero, preadditive.add_comp, comp_zero,
    preadditive.neg_comp, biprod.inr_fst, neg_zero, category.assoc] },
  ext; simp; refl
end

def termwise_split_epi_retraction_lift (f : A ‚ü∂ B) :
  homotopy (ùüô _) (termwise_split_epi_retraction f ‚â´ termwise_split_epi_lift f) :=
{ hom := Œª i j, if h : i = j + 1 then
    biprod.snd ‚â´ biprod.snd ‚â´ ((B‚ü¶(-1 : ‚Ñ§)‚üß).X_eq_to_iso h).hom ‚â´ biprod.inl ‚â´ biprod.inr else 0,
  zero' := Œª i j r, dif_neg (ne.symm r),
  comm := Œª i, by { dsimp,
    simpa [d_next, prev_d, cone.d] using termwise_split_epi_retraction_lift_aux i } }

instance (f : A ‚ü∂ B) (i : ‚Ñ§) : split_epi ((termwise_split_epi_desc f).f i) :=
{ section_ := (B.X_eq_to_iso $ eq_add_neg_of_add_eq rfl).hom ‚â´ biprod.inl ‚â´ biprod.inr,
  id' := by { dsimp, simp [cone.out], dsimp, simp } }

end termwise_split_epi_lift

section termwise_split_exact

variables (f g)

/--- **WARNING** this sign is different from stacks -/
@[simps]
def connecting_hom (h : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) : C ‚ü∂ A‚ü¶(1 : ‚Ñ§)‚üß :=
{ f := Œª i, (h i).section ‚â´ B.d i (i + 1) ‚â´ (h (i + 1)).retraction,
  comm' :=
  begin
    intros i j r,
    induction r,
    dsimp,
    rw ‚Üê cancel_mono (ùüô _),
    swap, apply_instance,
    conv_lhs { rw ‚Üê (h _).Œπ_retraction },
    simp only [preadditive.comp_neg, one_zsmul, category.assoc, neg_smul, preadditive.neg_comp,
      ‚Üê f.comm_assoc, (h _).retraction_Œπ_eq_id_sub_assoc, preadditive.sub_comp_assoc,
      preadditive.sub_comp, preadditive.comp_sub, category.id_comp, d_comp_d_assoc,
      zero_comp, comp_zero, ‚Üê g.comm_assoc, (h i).section_œÄ_assoc],
    simp,
  end }
.
@[simps]
def triangle_of_termwise_split (h : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) :
  triangulated.triangle (cochain_complex V ‚Ñ§) :=
triangulated.triangle.mk _ f g (connecting_hom f g h)

@[simps]
def triangle‚Çï_of_termwise_split (h : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) :
  triangulated.triangle (homotopy_category V (complex_shape.up ‚Ñ§)) :=
(homotopy_category.lift_triangle V).obj (triangle_of_termwise_split f g h)
.

@[simps]
def homotopy_connecting_hom_of_splittings (h h' : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) :
  homotopy (connecting_hom f g h) (connecting_hom f g h') :=
{ hom := Œª i j, if e : j + 1 = i then
    ((h' i).section ‚â´ (h i).retraction ‚â´ (A.X_eq_to_iso e).inv) else 0,
  comm := Œª i, by { rw ‚Üê cancel_epi (g.f _),
    dsimp, simp [d_next, prev_d, splitting.œÄ_section_eq_id_sub_assoc], abel, exact (h i).epi },
  zero' := Œª _ _ h, dif_neg h }

@[simps]
def triangle‚Çï_map_splittings_hom (h h' : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) :
  triangle‚Çï_of_termwise_split f g h ‚ü∂ triangle‚Çï_of_termwise_split f g h' :=
{ hom‚ÇÅ := ùüô _,
  hom‚ÇÇ := ùüô _,
  hom‚ÇÉ := ùüô _,
  comm‚ÇÉ' :=
  begin
    simp only [category.comp_id, triangle‚Çï_of_termwise_split_mor‚ÇÉ, category.id_comp,
      category_theory.functor.map_id],
    apply homotopy_category.eq_of_homotopy,
    exact homotopy_connecting_hom_of_splittings f g h h'
  end }

@[simps]
def triangle‚Çï_map_splittings_iso (h h' : ‚àÄ (i : ‚Ñ§), splitting (f.f i) (g.f i)) :
  triangle‚Çï_of_termwise_split f g h ‚âÖ triangle‚Çï_of_termwise_split f g h' :=
{ hom := triangle‚Çï_map_splittings_hom f g h h', inv := triangle‚Çï_map_splittings_hom f g h' h }

end termwise_split_exact

-- move these
lemma split_mono_of_splitting {C : Type*} [category C] [abelian C] {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}
  (h : splitting f g) : split_mono f := ‚ü®h.retraction, by simp‚ü©

lemma split_epi_of_splitting {C : Type*} [category C] [abelian C] {X Y Z : C} {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z}
  (h : splitting f g) : split_epi g := ‚ü®h.section, by simp‚ü©

section

variables {B'' B' : cochain_complex V ‚Ñ§} {b' : B'' ‚ü∂ B} {b : B ‚ü∂ B'}
variables (H‚ÇÇ : ‚àÄ i, splitting (f.f i) (g.f i))
variables (h‚ÇÇ : homotopy (b' ‚â´ g) 0) (h‚ÇÉ : homotopy (f ‚â´ b) 0)

include H‚ÇÇ h‚ÇÇ h‚ÇÉ

/--
If `A ‚ü∂ B ‚ü∂ C` is split exact, and `b ‚â´ g` and `f ‚â´ b'` are null-homotopic,
then so is `b' ‚â´ b`.

        B''
        ‚à£
        b'
        ‚Üì
A - f ‚Üí B - g ‚Üí C
        ‚à£
        b
        ‚Üì
        B'
-/
def comp_null_homotopic_of_row_split_exact : homotopy (b' ‚â´ b) 0 :=
begin
  haveI := Œª i, split_epi_of_splitting (H‚ÇÇ i),
  haveI := Œª i, split_mono_of_splitting (H‚ÇÇ i),
  haveI := Œª i, (H‚ÇÇ i).short_exact.3,
  let h‚ÇÅ' := (h‚ÇÇ.trans (homotopy.of_eq (comp_zero : ùüô _ ‚â´ 0 = 0).symm)).symm,
  let h‚ÇÇ' := (h‚ÇÉ.trans $ homotopy.of_eq (zero_comp : 0 ‚â´ ùüô _ = 0).symm),
  refine ((of_termwise_split_epi_homotopy h‚ÇÅ').symm.comp
    (of_termwise_split_mono_homotopy h‚ÇÇ')).trans (homotopy.of_eq _),
  ext i,
  exact comp_eq_zero_of_exact (f.f i) (g.f i)
    (congr_f ((of_termwise_split_epi_commutes h‚ÇÅ').trans comp_zero) i)
    (congr_f ((of_termwise_split_mono_commutes h‚ÇÇ').trans zero_comp) i)
end

end

def cone.termwise_split (i : ‚Ñ§) : splitting ((cone.in f).f i) ((cone.out f).f i) :=
{ iso := biprod.braiding _ _,
  comp_iso_eq_inl := by ext; simp [cone.in],
  iso_comp_snd_eq := by ext; simp [cone.out] }
.

def cone_homotopy_equiv_aux (c : cone f ‚ü∂ cone f) (h‚ÇÅ : homotopy (cone.in f ‚â´ c) (cone.in f))
  (h‚ÇÇ : homotopy (c ‚â´ cone.out f) (cone.out f)) : homotopy (ùüô _) (2 ‚Ä¢ c - c ‚â´ c) :=
begin
  have : homotopy ((ùüô _ - c) ‚â´ (ùüô _ - c)) 0,
  { apply comp_null_homotopic_of_row_split_exact (cone.in f) (cone.out f) (cone.termwise_split f),
    { refine (homotopy.of_eq _).trans h‚ÇÇ.symm.equiv_sub_zero, simp },
    { refine (homotopy.of_eq _).trans h‚ÇÅ.symm.equiv_sub_zero, simp } },
  apply homotopy.equiv_sub_zero.symm _,
  refine (homotopy.of_eq _).trans this,
  simp, abel,
end

local attribute [simp] preadditive.comp_nsmul preadditive.nsmul_comp

/--
If the following diagram commutes up to homotopy, then `c` is a homotopy equivalence
A - f ‚Üí B ‚ü∂ C(f) ‚ü∂ A‚ü¶1‚üß
|       |      ‚à£       ‚à£
ùüô       ùüô      c       ùüô
‚Üì       ‚Üì      ‚à£       ‚à£
A - f ‚Üí B ‚ü∂ C(f) ‚ü∂ A‚ü¶1‚üß
-/
def cone_homotopy_equiv (c : cone f ‚ü∂ cone f) (h‚ÇÅ : homotopy (cone.in f ‚â´ c) (cone.in f))
  (h‚ÇÇ : homotopy (c ‚â´ cone.out f) (cone.out f)) : homotopy_equiv (cone f) (cone f) :=
{ hom := c,
  inv := ((2 ‚Ä¢ ùüô _) - c),
  homotopy_hom_inv_id := (homotopy.of_eq (by simp)).trans (cone_homotopy_equiv_aux f c h‚ÇÅ h‚ÇÇ).symm,
  homotopy_inv_hom_id := (homotopy.of_eq (by simp)).trans (cone_homotopy_equiv_aux f c h‚ÇÅ h‚ÇÇ).symm }
.
-- move this
instance {Œπ : Type*} (c : complex_shape Œπ) : full (homotopy_category.quotient V c) :=
by { delta homotopy_category.quotient, apply_instance }

local notation `Q` := homotopy_category.quotient V (complex_shape.up ‚Ñ§)

lemma cone_triangle‚Çï_map_iso_of_id (œÜ : cone.triangle‚Çï f ‚ü∂ cone.triangle‚Çï f)
  (h‚ÇÅ : œÜ.hom‚ÇÅ = ùüô _) (h‚ÇÇ : œÜ.hom‚ÇÇ = ùüô _) : is_iso œÜ.hom‚ÇÉ :=
begin
  have e‚ÇÇ := œÜ.comm‚ÇÇ,
  have e‚ÇÉ := œÜ.comm‚ÇÉ,
  rw [h‚ÇÇ, category.id_comp] at e‚ÇÇ,
  rw [h‚ÇÅ, category_theory.functor.map_id, category.comp_id] at e‚ÇÉ,
  erw [‚Üê Q .image_preimage œÜ.hom‚ÇÉ, ‚Üê Q .map_comp] at e‚ÇÇ e‚ÇÉ,
  convert is_iso.of_iso (homotopy_category.iso_of_homotopy_equiv
    (cone_homotopy_equiv _ _ (homotopy_category.homotopy_of_eq _ _ e‚ÇÇ)
    (homotopy_category.homotopy_of_eq _ _ e‚ÇÉ.symm))),
  exact (Q .image_preimage _).symm
end

section

open category_theory.triangulated.triangle_morphism
-- move this
lemma triangle_morphism_is_iso {C : Type*} [category C] [has_shift C ‚Ñ§]
  {X Y : triangulated.triangle C} (f : X ‚ü∂ Y) [is_iso f.hom‚ÇÅ] [is_iso f.hom‚ÇÇ] [is_iso f.hom‚ÇÉ] :
  is_iso f :=
by { refine ‚ü®‚ü®‚ü®inv f.hom‚ÇÅ, inv f.hom‚ÇÇ, inv f.hom‚ÇÉ, _, _, _‚ü©, _, _‚ü©‚ü©; tidy }
.
instance {C : Type*} [category C] [has_shift C ‚Ñ§] {X Y : triangulated.triangle C} (f : X ‚ü∂ Y)
  [is_iso f] : is_iso f.hom‚ÇÅ :=
by { refine ‚ü®‚ü®(inv f).hom‚ÇÅ, _, _‚ü©‚ü©; simpa only [‚Üê comp_hom‚ÇÅ, ‚Üê triangulated.triangle_category_comp,
  is_iso.hom_inv_id, is_iso.inv_hom_id] }

instance {C : Type*} [category C] [has_shift C ‚Ñ§] {X Y : triangulated.triangle C} (f : X ‚ü∂ Y)
  [is_iso f] : is_iso f.hom‚ÇÇ :=
by { refine ‚ü®‚ü®(inv f).hom‚ÇÇ, _, _‚ü©‚ü©; simpa only [‚Üê comp_hom‚ÇÇ, ‚Üê triangulated.triangle_category_comp,
  is_iso.hom_inv_id, is_iso.inv_hom_id] }

instance {C : Type*} [category C] [has_shift C ‚Ñ§] {X Y : triangulated.triangle C} (f : X ‚ü∂ Y)
  [is_iso f] : is_iso f.hom‚ÇÉ :=
by { refine ‚ü®‚ü®(inv f).hom‚ÇÉ, _, _‚ü©‚ü©; simpa only [‚Üê comp_hom‚ÇÉ, ‚Üê triangulated.triangle_category_comp,
  is_iso.hom_inv_id, is_iso.inv_hom_id] }

lemma triangle_morphism_is_iso_iff {C : Type*} [category C] [has_shift C ‚Ñ§]
  {X Y : triangulated.triangle C} (f : X ‚ü∂ Y) : is_iso f ‚Üî
    is_iso f.hom‚ÇÅ ‚àß is_iso f.hom‚ÇÇ ‚àß is_iso f.hom‚ÇÉ :=
begin
  split,
  { intro _, refine ‚ü®_, _, _‚ü©; exactI infer_instance },
  { rintro ‚ü®_, _, _‚ü©, exactI triangle_morphism_is_iso f }
end

end

lemma cone.triangle‚Çï_is_iso {A' B' : cochain_complex V ‚Ñ§} {f : A ‚ü∂ B} {f' : A' ‚ü∂ B'}
  (œÜ : cone.triangle‚Çï f ‚ü∂ cone.triangle‚Çï f') [is_iso œÜ.hom‚ÇÅ] [is_iso œÜ.hom‚ÇÇ] : is_iso œÜ :=
begin
  suffices : is_iso œÜ.hom‚ÇÉ,
  { exactI triangle_morphism_is_iso _ },
  have := œÜ.comm‚ÇÅ,
  dsimp at this,
  rw [‚Üê is_iso.eq_comp_inv, category.assoc, ‚Üê is_iso.inv_comp_eq,
    ‚Üê Q .image_preimage (inv œÜ.hom‚ÇÅ), ‚Üê Q .map_comp,
    ‚Üê Q .image_preimage (inv œÜ.hom‚ÇÇ), ‚Üê Q .map_comp] at this,
  let T := cone.triangle‚Çï_map (homotopy_category.homotopy_of_eq _ _ this).symm,
  haveI := cone_triangle‚Çï_map_iso_of_id _ (œÜ ‚â´ T) (by simp) (by simp),
  haveI := cone_triangle‚Çï_map_iso_of_id _ (T ‚â´ œÜ) (by simp) (by simp),
  haveI : epi œÜ.hom‚ÇÉ := @@epi_of_epi _ (T.hom‚ÇÉ) (œÜ.hom‚ÇÉ) (show epi (T ‚â´ œÜ).hom‚ÇÉ, by apply_instance),
  use T.hom‚ÇÉ ‚â´ inv (œÜ ‚â´ T).hom‚ÇÉ,
  split,
  { rw ‚Üê category.assoc, exact is_iso.hom_inv_id _ },
  { rw [‚Üê cancel_epi œÜ.hom‚ÇÉ, ‚Üê category.assoc, ‚Üê category.assoc, category.comp_id,
      category.assoc],
    exact is_iso.hom_inv_id_assoc (œÜ ‚â´ T).hom‚ÇÉ _ }
end

instance : is_iso (from_termwise_split_mono_lift_triangle‚Çï f) :=
begin
  haveI : is_iso (from_termwise_split_mono_lift_triangle‚Çï f).hom‚ÇÅ,
  { delta from_termwise_split_mono_lift_triangle‚Çï, dsimp, apply_instance },
  haveI : is_iso (from_termwise_split_mono_lift_triangle‚Çï f).hom‚ÇÇ :=
    is_iso.of_iso (homotopy_category.iso_of_homotopy_equiv
      (termwise_split_mono_factor_homotopy_equiv f)),
  apply cone.triangle‚Çï_is_iso,
end

-- move this
@[simp]
lemma cochain_complex_d_next (i : ‚Ñ§) (f : Œ† i j, A.X i ‚ü∂ B.X j) :
  d_next i f = A.d i (i + 1) ‚â´ f (i + 1) i :=
by simp [d_next]

@[simp]
lemma cochain_complex_prev_d (i : ‚Ñ§) (f : Œ† i j, A.X i ‚ü∂ B.X j) :
  prev_d i f = f i (i - 1) ‚â´ B.d (i - 1) i :=
by simp [prev_d]

-- move this
section

@[simps]
def _root_.category_theory.triangulated.neg‚ÇÉ_functor (C : Type*) [category C] [has_shift C ‚Ñ§]
  [preadditive C] :
  triangulated.triangle C ‚•§ triangulated.triangle C :=
{ obj := Œª T, triangulated.triangle.mk C T.mor‚ÇÅ T.mor‚ÇÇ (-T.mor‚ÇÉ),
  map := Œª S T f, { hom‚ÇÅ := f.hom‚ÇÅ, hom‚ÇÇ := f.hom‚ÇÇ, hom‚ÇÉ := f.hom‚ÇÉ } }

@[simps]
def _root_.category_theory.triangulated.neg‚ÇÉ_unit_iso (C : Type*) [category C] [has_shift C ‚Ñ§]
  [preadditive C] : category_theory.triangulated.neg‚ÇÉ_functor C ‚ãô
    category_theory.triangulated.neg‚ÇÉ_functor C ‚âÖ ùü≠ _ :=
begin
  refine nat_iso.of_components
    (Œª X, ‚ü®‚ü®ùüô _, ùüô _, ùüô _, _, _, _‚ü©, ‚ü®ùüô _, ùüô _, ùüô _, _, _, _‚ü©, _, _‚ü©) (Œª X Y f, _),
  any_goals { ext },
  all_goals { dsimp,
    simp only [category.comp_id, category.id_comp, category_theory.functor.map_id, neg_neg] },
end
.
@[simps]
def _root_.category_theory.triangulated.neg‚ÇÉ_equiv (C : Type*) [category C] [has_shift C ‚Ñ§]
  [preadditive C] : triangulated.triangle C ‚âå triangulated.triangle C :=
{ functor := category_theory.triangulated.neg‚ÇÉ_functor C,
  inverse := category_theory.triangulated.neg‚ÇÉ_functor C,
  unit_iso := (category_theory.triangulated.neg‚ÇÉ_unit_iso C).symm,
  counit_iso := category_theory.triangulated.neg‚ÇÉ_unit_iso C }
.
end

@[simps]
def termwise_split_to_cone (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  C ‚ü∂ cone f :=
{ f := Œª i, biprod.lift (-(connecting_hom f g h).f i) ((h i).section),
  comm' := begin
    rintro i j (rfl : i + 1 = j),
    haveI := Œª i, split_epi_of_splitting (h i),
    haveI := Œª i, split_mono_of_splitting (h i),
    ext,
    { dsimp [cone.d],
      rw ‚Üê cancel_epi (g.f _),
      { simp [g.comm, splitting.œÄ_section_eq_id_sub_assoc] },
      { apply_instance } },
    { dsimp [cone.d],
      rw ‚Üê cancel_epi (g.f _),
      { simp [splitting.œÄ_section_eq_id_sub_assoc, splitting.œÄ_section_eq_id_sub] },
      { apply_instance } },
  end }
.

@[simps]
def comp_termwise_split_to_cone_homotopy (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  homotopy (g ‚â´ termwise_split_to_cone f g h) (cone.in f) :=
{ hom := Œª i j,
    if e : j + 1 = i then -(h i).retraction ‚â´ (A.X_eq_to_iso e).inv ‚â´ biprod.inl else 0,
  zero' := Œª _ _ r, dif_neg r,
  comm := Œª i, begin
    dsimp,
    simp only [dite_eq_ite, cochain_complex_prev_d, dif_pos, if_true, category.assoc, cone_d,
      category.id_comp, add_left_inj, sub_add_cancel, dif_ctx_congr, X_eq_to_iso_refl, cone.d,
      preadditive.comp_neg, eq_self_iff_true, cochain_complex_d_next, preadditive.neg_comp],
    ext,
    { simp [cone.in, splitting.œÄ_section_eq_id_sub_assoc, ‚Üê sub_eq_add_neg] },
    { simp [cone.in, splitting.retraction_Œπ_eq_id_sub, ‚Üê sub_eq_add_neg] },
  end }
.

-- move this
lemma _root_.category_theory.splitting.comp_eq_zero {C : Type*} [category C] [abelian C] {X Y Z : C}
  {f : X ‚ü∂ Y} {g : Y ‚ü∂ Z} (h : splitting f g) : f ‚â´ g = 0 :=
h.split.1.some_spec.some_spec.2.2.1

@[simps]
def cone_to_termwise_split (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  cone f ‚ü∂ C :=
{ f := Œª i, biprod.snd ‚â´ g.f i,
  comm' := begin
    rintro i j (rfl : i + 1 = j),
    ext; simp [cone.d, (h _).comp_eq_zero],
  end }

@[simps]
def cone_to_termwise_split_comp_homotopy (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  homotopy (cone_to_termwise_split f g h ‚â´ connecting_hom f g h) (-cone.out f) :=
{ hom := Œª i j,
    if e : j + 1 = i then biprod.snd ‚â´ (h i).retraction ‚â´ (A.X_eq_to_iso e).inv else 0,
  zero' := Œª _ _ r, dif_neg r,
  comm := begin
    intro i,
    dsimp,
    simp only [category.comp_id, dite_eq_ite, cochain_complex_prev_d, cone.out, dif_pos, if_true,
      add_left_inj, sub_add_cancel, cone.d, shift_d, dif_ctx_congr, preadditive.comp_neg,
      eq_self_iff_true, int.neg_one_pow_one, cochain_complex_d_next, one_zsmul,
      category.assoc, X_eq_to_iso_d, neg_neg, neg_smul, biprod.lift_snd_assoc,
      X_eq_to_iso_refl, cone_d, preadditive.neg_comp],
    ext; simp [splitting.œÄ_section_eq_id_sub_assoc, sub_eq_add_neg],
  end }
.
def iso_cone_of_termwise_split_inv_hom_homotopy (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  homotopy (cone_to_termwise_split f g h ‚â´ termwise_split_to_cone f g h) (ùüô _) :=
{ hom := Œª i j, if e : j + 1 = i then
    -biprod.snd ‚â´ (h i).retraction ‚â´ (A.X_eq_to_iso e).inv ‚â´ biprod.inl else 0,
  zero' := Œª _ _ r, dif_neg r,
  comm := begin
    intro i,
    dsimp,
    simp only [category.comp_id, dite_eq_ite, cochain_complex_prev_d, dif_pos, if_true,
      category.id_comp, add_left_inj, sub_add_cancel, cone.d, dif_ctx_congr,
      eq_self_iff_true, cochain_complex_d_next, category.assoc, biprod.lift_snd_assoc,
      X_eq_to_iso_refl, cone_d],
    ext; -- This is simp [splitting.œÄ_section_eq_id_sub_assoc, splitting.œÄ_section_eq_id_sub]
      simp only [add_left_neg, add_zero, category.assoc, category.comp_id, exact.w, exact.w_assoc,
        biprod.inl_desc, biprod.inl_desc_assoc, biprod.inl_fst, biprod.inr_desc_assoc,
        biprod.inr_fst, biprod.inr_snd, biprod.inr_snd_assoc, biprod.lift_fst, biprod.lift_snd,
        biprod.lift_snd_assoc, comp_zero, zero_comp, preadditive.add_comp, preadditive.comp_add,
        preadditive.comp_neg, preadditive.neg_comp, preadditive.neg_comp, category.comp_id,
        splitting.Œπ_retraction_assoc, eq_self_iff_true, X_eq_to_iso_d, X_eq_to_iso_f_assoc,
        X_eq_to_iso_refl, X_eq_to_iso_trans, neg_neg, neg_zero, zero_add, neg_sub, hom.comm_assoc,
        splitting.œÄ_section_eq_id_sub_assoc, splitting.œÄ_section_eq_id_sub, category.id_comp,
        preadditive.sub_comp_assoc, hom.comm, preadditive.sub_comp, splitting.Œπ_retraction];
      abel
  end }
.
section

-- move & generalize this
instance homotopy_category.has_add {X Y : homotopy_category V (complex_shape.up ‚Ñ§)} :
  has_add (X ‚ü∂ Y) :=
‚ü®Œª f g, Q .map (Q .preimage f + Q .preimage g)‚ü©

@[simp]
lemma quotient_map_add {f g : A ‚ü∂ B} : Q .map (f + g) = Q .map f + Q .map g :=
begin
  delta homotopy_category.has_add,
  apply homotopy_category.eq_of_homotopy,
  apply homotopy.add; { apply homotopy_category.homotopy_of_eq, simp },
end

instance homotopy_category.hom.add_comm_group {X Y : homotopy_category V (complex_shape.up ‚Ñ§)} :
  add_comm_group (X ‚ü∂ Y) :=
{ zero := Q .map 0,
  neg := Œª f, Q .map (- Q .preimage f),
  add_assoc := Œª _ _ _, by { dsimp [homotopy_category.has_add],
    rw [quotient_map_add, functor.image_preimage, ‚Üê quotient_map_add, add_assoc], simp },
  zero_add := Œª f, by { rw [‚Üê Q .image_preimage f, ‚Üê quotient_map_add, zero_add] },
  add_zero := Œª f, by { rw [‚Üê Q .image_preimage f, ‚Üê quotient_map_add, add_zero] },
  add_comm := Œª f g, by { rw [‚Üê Q .image_preimage f, ‚Üê Q .image_preimage g, ‚Üê quotient_map_add,
    add_comm], simp },
  add_left_neg := Œª f, by { nth_rewrite 1 ‚Üê Q .image_preimage f, erw ‚Üê quotient_map_add,
    rw add_left_neg, refl },
 ..homotopy_category.has_add }
.

instance : preadditive (homotopy_category V (complex_shape.up ‚Ñ§)) :=
{ add_comp' := Œª _ _ _ f g h, begin
    rw ‚Üê Q .image_preimage h,
    nth_rewrite 1 ‚Üê Q .image_preimage f,
    nth_rewrite 1 ‚Üê Q .image_preimage g,
    erw [‚Üê Q .map_comp, ‚Üê quotient_map_add],
    rw preadditive.add_comp,
  end,
  comp_add' := Œª _ _ _ f g h, begin
    rw ‚Üê Q .image_preimage f,
    nth_rewrite 1 ‚Üê Q .image_preimage g,
    nth_rewrite 1 ‚Üê Q .image_preimage h,
    erw [‚Üê Q .map_comp, ‚Üê quotient_map_add],
    rw preadditive.comp_add,
  end }

instance quotient_additive : Q .additive := {}
end

@[simps]
def iso_cone_of_termwise_split (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  triangle‚Çï_of_termwise_split f g h ‚âÖ
    (category_theory.triangulated.neg‚ÇÉ_functor _).obj (cone.triangle‚Çï f) :=
{ hom :=
  { hom‚ÇÅ := ùüô _,
    hom‚ÇÇ := ùüô _,
    hom‚ÇÉ := Q .map (termwise_split_to_cone f g h),
    comm‚ÇÅ' := (category.comp_id _).trans (category.id_comp _).symm,
    comm‚ÇÇ' := by { dsimp, rw [‚Üê Q .map_comp, category.id_comp],
      apply homotopy_category.eq_of_homotopy, apply comp_termwise_split_to_cone_homotopy },
    comm‚ÇÉ' := by { dsimp, rw [category_theory.functor.map_id, category.comp_id,
      ‚Üê Q .map_neg, ‚Üê Q .map_comp], congr, ext, simp [cone.out] } },
  inv :=
  { hom‚ÇÅ := ùüô _,
    hom‚ÇÇ := ùüô _,
    hom‚ÇÉ := Q .map (cone_to_termwise_split f g h),
    comm‚ÇÅ' := (category.comp_id _).trans (category.id_comp _).symm,
    comm‚ÇÇ' := by { dsimp, rw [‚Üê Q .map_comp, category.id_comp], congr, ext, simp [cone.in] },
    comm‚ÇÉ' := by { dsimp, rw [category_theory.functor.map_id, category.comp_id, ‚Üê Q .map_comp,
      ‚Üê Q .map_neg], symmetry, apply homotopy_category.eq_of_homotopy,
      apply cone_to_termwise_split_comp_homotopy }, },
  hom_inv_id' := by { ext, { exact category.comp_id _ }, { exact category.comp_id _ },
    dsimp, erw [‚Üê Q .map_comp, ‚Üê Q .map_id], congr, ext; dsimp, simp },
  inv_hom_id' := by { ext, { exact category.comp_id _ }, { exact category.comp_id _ },
    dsimp, erw [‚Üê Q .map_comp, ‚Üê Q .map_id], apply homotopy_category.eq_of_homotopy,
    apply iso_cone_of_termwise_split_inv_hom_homotopy } }
.
--move this
lemma mono_of_eval [‚àÄ i, mono (f.f i)] : mono f :=
begin
  constructor,
  intros Z g h r,
  ext i,
  rw ‚Üê cancel_mono (f.f i),
  exact congr_f r i
end

instance : mono (termwise_split_mono_lift f) := mono_of_eval _

def termwise_split_of_termwise_split_mono [H : ‚àÄ i, split_mono (f.f i)] (i : ‚Ñ§) :
  splitting (f.f i)
    ((@@homological_complex.normal_mono _ _ f (mono_of_eval _)).g.f i) :=
begin
  apply left_split.splitting, -- This uses a sorry :(
  dsimp only [normal_mono, cokernel_complex_œÄ],
  haveI : exact (f.f i) (cokernel.œÄ (f.f i)) := abelian.exact_cokernel _,
  constructor,
  exact ‚ü®(H i).1, (H i).2‚ü©
end

/-- Every neg‚ÇÉ of a cone triangle is isomorphic to some triangle associated to some
  termwise split sequence -/
def iso_termwise_split_of_cone :
      (category_theory.triangulated.neg‚ÇÉ_functor _).obj (cone.triangle‚Çï f) ‚âÖ
    triangle‚Çï_of_termwise_split (termwise_split_mono_lift f)
      (homological_complex.normal_mono (termwise_split_mono_lift f)).g
    (termwise_split_of_termwise_split_mono _) :=
functor.map_iso _ (as_iso $ from_termwise_split_mono_lift_triangle‚Çï f).symm ‚â™‚â´
  (iso_cone_of_termwise_split _ _ _).symm
.

-- Lemma 13.9.15. skipped

def inv_rotate_iso_cone_triangle (h : ‚àÄ i, splitting (f.f i) (g.f i)) :
  (triangle_of_termwise_split f g h).inv_rotate ‚âÖ
    cone.triangle ((connecting_hom f g h)‚ü¶(-1 : ‚Ñ§)‚üß') := sorry

end homological_complex
