import topology.category.Profinite.cofiltered_limit
import topology.discrete_quotient

import for_mathlib.topology
import for_mathlib.order
import for_mathlib.discrete_quotient
import for_mathlib.Profinite.locally_constant

noncomputable theory

open_locale classical

namespace Profinite

open category_theory
open category_theory.limits

universe u

variables {J : Type u} [semilattice_inf J] (F : J ⥤ Profinite.{u}) (C : cone F)

lemma image_eq (hC : is_limit C) (i : J) :
  set.range (C.π.app i) = ⋂ (j : J) (h : j ≤ i), set.range (F.map (hom_of_le h)) :=
begin
  refine le_antisymm _ _,
  { apply set.subset_Inter,
    intros j,
    apply set.subset_Inter,
    intros hj,
    rw ← C.w (hom_of_le hj),
    apply set.range_comp_subset_range },
  { rintro x hx,
    have cond : ∀ (j : J) (hj : j ≤ i), ∃ y : F.obj j, (F.map (hom_of_le hj)) y = x,
    { intros j hj,
      exact hx _ ⟨j,rfl⟩ _ ⟨hj, rfl⟩ },
    let Js := Σ' (a b : J), a ≤ b,
    let P := Π (j : J), F.obj j,
    let Us : Js → set P := λ e, { p | F.map (hom_of_le e.2.2) (p (e.1)) = p (e.2.1) ∧ p i = x},
    haveI : compact_space P := by apply_instance,
    have hP : (_root_.is_compact (set.univ : set P)) := compact_univ,
    have hh := hP.inter_Inter_nonempty Us _ _,
    { rcases hh with ⟨z,hz⟩,
      let IC : (limit_cone F) ≅ C := (limit_cone_is_limit F).unique_up_to_iso hC,
      let ICX : (limit_cone F).X ≅ C.X := (cones.forget _).map_iso IC,
      let z : (limit_cone F).X := ⟨z,_⟩,
      swap,
      { dsimp,
        intros a b h,
        let e : Js := ⟨a,b,le_of_hom h⟩,
        cases hz with _ hz,
        specialize hz _ ⟨e,rfl⟩,
        dsimp at hz,
        cases hz with hz _,
        convert hz },
      use ICX.hom z,
      dsimp,
      change (hC.lift _ ≫ _) _ = _,
      rw hC.fac,
      cases hz with _ hz,
      specialize hz _ ⟨⟨i,i,le_refl _⟩,rfl⟩,
      exact hz.2 },
    { intros i,
      apply is_closed.inter,
      apply is_closed_eq,
      continuity,
      apply is_closed_eq,
      continuity },
    { have : ∀ e : J, nonempty (F.obj e),
      { intros e,
        let ee := e ⊓ i,
        specialize cond ee inf_le_right,
        rcases cond with ⟨y,rfl⟩,
        use F.map (hom_of_le inf_le_left) y },
      haveI : ∀ j : J, inhabited (F.obj j) :=
        by {intros j, refine ⟨nonempty.some (this j)⟩},
      intros G,
      let GG := G.image (λ e : Js, e.1),
      haveI : inhabited J := ⟨i⟩,
      have := exists_le_finset (insert i GG),
      obtain ⟨j0,hj0⟩ := this,
      obtain ⟨x0,rfl⟩ := cond j0 (hj0 _ (finset.mem_insert_self _ _)),
      let z : P := λ e, if h : j0 ≤ e then F.map (hom_of_le h) x0 else (default _),
      use z,
      refine ⟨trivial, _⟩,
      rintros S ⟨e,rfl⟩,
      dsimp,
      rintro T ⟨k,rfl⟩,
      dsimp,
      split,
      { dsimp [z],
        have : j0 ≤ e.fst,
        { apply hj0,
          rw finset.mem_insert,
          right,
          dsimp [GG],
          rw finset.mem_image,
          use e,
          refine ⟨k,rfl⟩ },
        erw dif_pos this,
        erw dif_pos (le_trans this e.2.2),
        change (F.map _ ≫ F.map _) _ = _,
        rw ← F.map_comp,
        refl },
      { dsimp [z],
        erw dif_pos } } }
end

theorem exists_clopen_finite [nonempty J]
  (hC : is_limit C) (S : Type*) [fintype S]
  (Us : S → set C.X) (hUs : ∀ i, is_clopen (Us i)) :
  ∃ (j : J) (Vs : S → set (F.obj j)) (hVs : ∀ i, is_clopen (Vs i)),
    ∀i,  Us i = (C.π.app j) ⁻¹' (Vs i) :=
begin
  have := λ (i : S), exists_clopen_of_cofiltered _ hC (hUs i),
  choose js hjs using this,
  choose Vs hVs using hjs,
  let FF : finset J := (finset.univ : finset S).image js,
  obtain ⟨j0,hj0⟩ := is_cofiltered.inf_objs_exists FF,
  use j0,
  have hj0S : ∀ s : S, j0 ≤ js s,
  { intros s,
    apply le_of_hom (hj0 _).some,
    dsimp [FF],
    simp [finset.image] },
  let Ws : S → set (F.obj j0) := λ s, F.map (hom_of_le (hj0S s)) ⁻¹' (Vs s),
  use Ws,
  split,
  { intros s,
    split,
    { apply is_open.preimage,
      continuity,
      refine (hVs _).1.1 },
    { apply is_closed.preimage,
      continuity,
      refine (hVs _).1.2 } },
  { intros i,
    dsimp [Ws],
    rw [← set.preimage_comp, ← Profinite.coe_comp, C.w],
    apply (hVs _).2 }
end

set_option pp.proofs true

lemma image_stabilizes [inhabited J] [∀ i, fintype (F.obj i)]
  (i : J) : ∃ (j : J) (hj : j ≤ i), ∀ (k : J) (hk : k ≤ j),
  set.range (F.map (hom_of_le $ le_trans hk hj)) =
  set.range (F.map (hom_of_le hj)) :=
begin
  have := eventually_constant i
    (λ e he, set.range (F.map (hom_of_le he))) _,
  swap,
  { intros a b ha hb h,
    dsimp,
    have : hom_of_le ha = (hom_of_le h) ≫ (hom_of_le hb) := rfl,
    rw [this, F.map_comp, Profinite.coe_comp],
    apply set.range_comp_subset_range },
  obtain ⟨j0,hj0,hh⟩ := this,
  use j0, use hj0,
  exact hh,
end

/-- The images of the transition maps stabilize, in which case they agree with
the image of the cone point. -/
theorem exists_image [inhabited J] [∀ i, fintype (F.obj i)]
  (hC : is_limit C) (i : J) : ∃ (j : J) (hj : j ≤ i),
  set.range (C.π.app i) = set.range (F.map $ hom_of_le $ hj) :=
begin
  have := Inter_eq i (λ e he, set.range (F.map (hom_of_le he))) _,
  swap,
  { intros a b ha hb hh,
    dsimp,
    have : hom_of_le ha = hom_of_le hh ≫ hom_of_le hb, refl,
    rw [this, F.map_comp, Profinite.coe_comp],
    apply set.range_comp_subset_range },
  obtain ⟨j0,hj0,hh⟩ := this,
  dsimp at hh,
  use j0, use hj0,
  rw [image_eq _ _ hC, ← hh],
end

/-- Any discrete quotient arises from some point in the limit. -/
theorem exists_discrete_quotient [inhabited J] (hC : is_limit C)
  (S : discrete_quotient C.X) : ∃ (i : J) (T : discrete_quotient (F.obj i)),
  S.rel = (T.comap (C.π.app i).continuous).rel :=
begin
  have := exists_clopen_finite F C hC S
    (λ s, S.proj ⁻¹' {s}) _,
    swap,
    { intros s,
      apply S.fiber_clopen },
  obtain ⟨j,Vs,hVsClopen,hVsEq⟩ := this,
  use j,
  let Tp : S → F.obj j → Prop := λ s a,
    a ∈ Vs s ∧ ∀ t, t ≠ s → a ∉ Vs t,
  have hTpEq : ∀ (s : S), set_of (Tp s) =
    Vs s \ ⋃ (t : S) (ht : t ≠ s), Vs t,
  { intros s,
    ext x,
    split,
    { intros hx,
      split,
      { exact hx.1 },
      { simp,
        intros t ht,
        exact hx.2 _ ht } },
    { rintros ⟨hx1,hx2⟩,
      simp at hx2,
      refine ⟨hx1,hx2⟩ } },
  have useful : ∀ (s t : S) (x : F.obj j), Tp s x → Tp t x → s = t,
  { intros s t x h1 h2,
    cases h1 with h11 h12, cases h2 with h21 h22,
    by_contra c,
    specialize h22 s c,
    apply h22,
    exact h11 },
  let Trel : F.obj j → F.obj j → Prop := λ a b,
    (∃ s : S, Tp s a ∧ Tp s b) ∨ -- either a and b are in the same Tprerel.
    (∀ s : S, ¬ Tp s a ∧ ¬ Tp s b), -- or theyre both in everything else.
  have hTrelEq1 : ∀ (x : F.obj j) (s : S) (cond : Tp s x),
    set_of (Trel x) = set_of (Tp s),
  { rintros x s hx,
    ext y, split,
    { rintro hy,
      rcases hy with ⟨t,ht⟩,
      { have : s = t, { apply useful, exact hx, exact ht.1 },
        rw this,
        exact ht.2 },
      { exfalso,
        exact (hy s).1 hx } },
    { intro hy,
      exact or.inl (Exists.intro s (id ⟨hx, hy⟩)) } },
  have hTrelEq2 : ∀ (x : F.obj j) (cond : ∀ s, ¬ Tp s x),
    set_of (Trel x) = set.univ \ ⋃ (s : S), set_of (Tp s),
  { intros x hx,
    ext y, split,
    { intros hy,
      simp,
      intros s hs,
      cases hy,
      { rcases hy with ⟨t,ht1,ht2⟩,
        use t,
        refine ⟨_,ht2.1⟩,
        intro c,
        rw c at ht1,
        apply hx _ ht1 },
      { by_contra c,
        push_neg at c,
        apply (hy s).2,
        refine ⟨hs, c⟩ } },
    { intros hy,
      simp at hy,
      right,
      intros s,
      split,
      { apply hx s },
      { push_neg,
        intros hy',
        specialize hy s hy',
        exact hy } } },
  let T : discrete_quotient (F.obj j),
  { refine ⟨Trel,_,_⟩,
    { refine ⟨_,_,_⟩,
      { intros x,
        by_cases h : ∃ s : S, Tp s x,
        { left,
          rcases h with ⟨s,hs⟩,
          use s,
          exact ⟨hs,hs⟩ },
        { right,
          intros s,
          rw not_exists at h,
          specialize h s,
          exact ⟨h,h⟩ } },
      { intros a b h,
        cases h,
        { left,
          cases h with s h,
          use s, exact ⟨h.2,h.1⟩ },
        { right,
          intros s,
          exact ⟨(h s).2, (h s).1⟩ } },
      { intros a b c h1 h2,
        cases h1; cases h2,
        { left,
          rcases h1 with ⟨s,h1,h1'⟩,
          rcases h2 with ⟨t,h2,h2'⟩,
          use s,
          have : s = t, { apply useful, exact h1', exact h2 },
          refine ⟨h1,_⟩,
          rw this,
          exact h2' },
        { rcases h1 with ⟨s,h1,h2'⟩,
          exfalso,
          exact (h2 s).1 h2' },
        { rcases h2 with ⟨s,h1',h2'⟩,
          exfalso,
          exact (h1 s).2 h1' },
        { right,
          intros s,
          refine ⟨(h1 s).1, (h2 s).2⟩ } } },
    { intros x,
      by_cases hx : ∃ s : S, Tp s x,
      { rcases hx with ⟨s,hs⟩,
        rw hTrelEq1 x s hs,
        rw hTpEq,
        apply is_clopen.diff,
        { apply hVsClopen },
        { split,
          { apply is_open_bUnion,
            intros i hi,
            apply (hVsClopen _).1 },
          { apply is_closed_bUnion,
            { exact set.finite.of_fintype (λ (i : ↥S), i = s → false) },
            { intros i hi,
              apply (hVsClopen _).2 } } } },
      { rw not_exists at hx,
        rw hTrelEq2 x hx,
        apply is_clopen.diff,
        { exact is_clopen_univ },
        { split,
          { apply is_open_Union,
            intros s,
            rw hTpEq,
            apply is_open.sdiff,
            { exact (hVsClopen _).1 },
            { apply is_closed_bUnion,
              { exact set.finite.of_fintype (λ (i : ↥S), i = s → false) },
              intros t ht,
              apply (hVsClopen _).2 } },
          { apply is_closed_Union,
            intros t,
            rw hTpEq,
            apply is_closed.sdiff,
            exact (hVsClopen _).2,
            apply is_open_bUnion,
            intros s hs,
            apply (hVsClopen _).1 } } } } },
  use T,
  ext a b,
  dsimp at hVsEq,
  split,
  { intros ha,
    left,
    use S.proj a,
    split,
    { split,
      { change a ∈ (C.π.app j) ⁻¹' (Vs (S.proj a)),
        rw ← hVsEq,
        simp },
      intros t ht,
      obtain ⟨t,rfl⟩ := S.proj_surjective t,
      change a ∉ (C.π.app j) ⁻¹' (Vs (S.proj t)),
      rw ← hVsEq,
      simp [ht.symm] },
    { split,
      { change b ∈ (C.π.app j) ⁻¹' (Vs (S.proj a)),
        rw ← hVsEq,
        simp,
        symmetry,
        apply quotient.sound',
        exact ha },
      { intros t ht,
        change b ∉ (C.π.app j) ⁻¹' (Vs t),
        obtain ⟨t,rfl⟩ := S.proj_surjective t,
        rw ← hVsEq,
        have : S.proj a = S.proj b,
        { apply quotient.sound,
          exact ha },
        rw this at ht,
        simp [ht.symm] } } },
  { intros h,
    cases h,
    { rcases h with ⟨s,⟨h11,h12⟩,⟨h21,h22⟩⟩,
      change a ∈ (C.π.app j) ⁻¹' (Vs s) at h11,
      change b ∈ (C.π.app j) ⁻¹' (Vs s) at h21,
      rw ← hVsEq at h11 h21,
      simp at h21 h11,
      rw ← h21 at h11,
      replace h11 := quotient.exact' h11,
      exact h11 },
    { exfalso,
      specialize h (S.proj a),
      rcases h with ⟨h1,h2⟩,
      apply h1,
      split,
      { change a ∈ (C.π.app j) ⁻¹' Vs (S.proj a),
        rw ←  hVsEq,
        simp },
      { intros t,
        contrapose,
        simp,
        intros ha,
        change a ∈ (C.π.app j) ⁻¹' Vs t at ha,
        rw ← hVsEq at ha,
        symmetry,
        simpa using ha } } }
end

theorem exists_locally_constant_factors {α : Type*} [nonempty α] [inhabited J]
  (hC : is_limit C) (ff : locally_constant C.X α) : ∃ (i : J)
  (gg : locally_constant (F.obj i) α), gg ∘ (C.π.app i) = ff :=
begin
  let S : discrete_quotient C.X := ff.to_discrete_quotient,
  let fff : S → α := ff.desc',
  have hfff : fff ∘ S.proj = _ := ff.factors',
  obtain ⟨i,T,hT⟩ := exists_discrete_quotient F C hC S,
  have h := discrete_quotient.le_comap_of_eq _ _ hT,
  let ι : S → T := discrete_quotient.map h,
  let σ : T → α := choose_extension ι fff,
  let gg : locally_constant (F.obj i) α :=
    ⟨σ ∘ T.proj ,_⟩,
  swap,
  { intros U,
    rw set.preimage_comp,
    apply T.proj_is_locally_constant },
  use i, use gg,
  rw ← hfff,
  ext, dsimp,
  dsimp [σ],
  have : function.injective ι := discrete_quotient.map_injective _ _ _ hT,
  rw ← choose_extension_injective ι fff this,
  refl,
end

end Profinite
