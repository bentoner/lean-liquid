import for_mathlib.Cech.split
import for_mathlib.Profinite.functorial_limit
import for_mathlib.simplicial.complex
import for_mathlib.SemiNormedGroup
import for_mathlib.homological_complex

import locally_constant.Vhat
import prop819.completion

open_locale nnreal

noncomputable theory

open category_theory opposite
open SemiNormedGroup

universes u

-- We have a surjective morphism of profinite sets.
variables (F : arrow Profinite.{u}) (surj : function.surjective F.hom)
variables (M : SemiNormedGroup.{u})

abbreviation FL : cochain_complex SemiNormedGroup ‚Ñï :=
  (((cosimplicial_object.augmented.whiskering _ _).obj (LocallyConstant.{u u}.obj M)).obj
  F.augmented_cech_nerve.right_op).to_cocomplex

abbreviation FLC : cochain_complex SemiNormedGroup ‚Ñï :=
  (((cosimplicial_object.augmented.whiskering _ _).obj (LCC.{u u}.obj M)).obj
  F.augmented_cech_nerve.right_op).to_cocomplex

--def Rop : (simplicial_object.augmented Profinite)·µí·µñ ‚•§ cosimplicial_object.augmented Profinite·µí·µñ :=
--{ obj := Œª X, X.unop.right_op,
--  map := Œª X Y f,
--  { left := quiver.hom.op (comma_morphism.right f.unop),
--    right := nat_trans.right_op (comma_morphism.left f.unop),
--    w' := by { ext, exact congr_arg (Œª Œ∑, (nat_trans.app Œ∑ (op x)).op) f.unop.w.symm, } } }

def FLC_functor : (arrow Profinite.{u})·µí·µñ ‚•§ cochain_complex SemiNormedGroup ‚Ñï :=
simplicial_object.augmented_cech_nerve.op ‚ãô
  simplicial_to_cosimplicial_augmented _ ‚ãô
  (cosimplicial_object.augmented.whiskering _ _).obj (LCC.{u u}.obj M) ‚ãô
  cosimplicial_object.augmented.cocomplex

lemma _root_.cosimplicial_object.augmented.cocomplex_map_norm_noninc
  {C‚ÇÅ C‚ÇÇ : cosimplicial_object.augmented SemiNormedGroup} (f : C‚ÇÅ ‚ü∂ C‚ÇÇ)
  (hf1 : f.left.norm_noninc) (hf2 : ‚àÄ n, (f.right.app n).norm_noninc) (i : ‚Ñï) :
  ((cosimplicial_object.augmented.cocomplex.map f).f i).norm_noninc :=
begin
  cases i,
  { exact hf1 },
  { exact hf2 _ },
end

lemma FLC_functor_map_norm_noninc {f g : (arrow Profinite.{u})·µí·µñ} (Œ± : f ‚ü∂ g) (i : ‚Ñï) :
  (((FLC_functor M).map Œ±).f i).norm_noninc :=
begin
  refine cosimplicial_object.augmented.cocomplex_map_norm_noninc _ _ _ _,
  { exact SemiNormedGroup.LCC_obj_map_norm_noninc _ _ },
  { intro n,
    exact SemiNormedGroup.LCC_obj_map_norm_noninc _ _ },
end

--‚ä¢ cosimplicial_object.Œ¥
--      (functor.right_op F.cech_nerve ‚ãô (curry.obj (uncurry.obj LocallyConstant ‚ãô Completion)).obj M)
--      k =
--    Completion.map (cosimplicial_object.Œ¥ (functor.right_op F.cech_nerve ‚ãô LocallyConstant.obj M) k)

lemma FLC_iso_helper {x y : simplex_category} (f : x ‚ü∂ y) :
  (F.cech_nerve.right_op ‚ãô LCC.obj M).map f =
  Completion.map ((F.cech_nerve.right_op ‚ãô LocallyConstant.obj M).map f) :=
begin
  change Completion.map _ = _,
  congr' 1,
  dsimp [uncurry],
  erw locally_constant.map_hom_id,
  change ùüô _ ‚â´ _ = _,
  rw category.id_comp,
end

def FLC_iso : strict_iso ((Completion.map_homological_complex _).obj (FL F M)) (FLC F M) :=
{ iso := homological_complex.iso_of_components (Œª i,
    match i with
    | 0 := eq_to_iso rfl
    | n+1 := eq_to_iso rfl
    end) begin
      rintro (_|i) (_|j) h; rcases h with _|‚ü®i,w‚ü©; ext; dsimp [FLC_iso._match_1];
        split_ifs with hh hh,
      { simp only [category.id_comp, category.comp_id, Completion_map_apply],
        dsimp only [cosimplicial_object.augmented.to_cocomplex_d,
          cosimplicial_object.augmented.drop, comma.snd, cosimplicial_object.whiskering,
          whiskering_right, cosimplicial_object.coboundary, functor.const_comp, LCC],
        simpa },
      { exfalso,
        apply hh,
        refl },
      { simp only [category.id_comp, category.comp_id, Completion_map_apply],
        dsimp only [cosimplicial_object.augmented.to_cocomplex_d,
          cosimplicial_object.augmented.drop, comma.snd, cosimplicial_object.whiskering,
          whiskering_right, cosimplicial_object.coboundary, LCC],
        rw [‚Üê Completion_map_apply, Completion.map_sum],
        congr,
        funext k,
        rw [Completion.map_gsmul],
        congr' 1,
        apply FLC_iso_helper },
      { exfalso,
        apply hh,
        refl }
    end,
  is_strict := Œª i, { strict_hom' := Œª a, by { cases i; refl } } }.

open_locale simplicial

-- TODO: Move this to mathlib (also relax the has_limits condition).
/-- the iso between the 0-th term of the Cech nerve and F.left-/
@[simps]
def cech_iso_zero {C : Type*} [category C] (F : arrow C) [limits.has_limits C]
  : F.cech_nerve _[0] ‚âÖ F.left :=
{ hom := limits.wide_pullback.œÄ _ ‚ü®0‚ü©,
  inv := limits.wide_pullback.lift F.hom (Œª _, ùüô _) (by simp),
  hom_inv_id' := begin
    apply limits.wide_pullback.hom_ext,
    { intro i,
      simp only [limits.wide_pullback.lift_œÄ, category.id_comp, category.comp_id, category.assoc],
      congr,
      tidy },
    { simp }
  end }

lemma augmentation_zero {C : Type*} [category C] (F : arrow C) [limits.has_limits C] :
  (cech_iso_zero F).inv ‚â´ F.augmented_cech_nerve.hom.app _ = F.hom := by tidy

lemma locally_constant_norm_empty (X : Profinite) (hX : ¬¨ nonempty X)
  (g : (LocallyConstant.obj M).obj (op X)) : ‚à• g ‚à• = 0 :=
begin
  rw locally_constant.norm_def,
  dsimp [supr],
  suffices : set.range (Œª x : ‚Ü•X, ‚à• g.to_fun x ‚à•) = ‚àÖ,
  { erw [this, real.Sup_empty],  },
  simp only [set.range_eq_empty, not_nonempty_iff],
  exact not_nonempty_iff.mp hX
end

include surj

lemma prop819_degree_zero_helper :
  function.surjective (limits.wide_pullback.base (Œª i : ulift (fin 1), F.hom)) :=
begin
  intro x,
  obtain ‚ü®x,rfl‚ü© := surj x,
  dsimp at *,
  refine ‚ü®(cech_iso_zero F).inv x, _‚ü©,
  dsimp,
  change (limits.wide_pullback.lift F.hom _ _ ‚â´ limits.wide_pullback.base _) _ = _,
  simp,
end

lemma prop819_zero_norm_le (g : (LocallyConstant.obj M).obj (op F.right)) : ‚à• g ‚à• ‚â§
  ‚à• (LocallyConstant.obj M).map (limits.wide_pullback.base (Œª i : ulift (fin 1), F.hom)).op g ‚à• :=
begin
  by_cases hh : nonempty F.right,
  { erw real.Sup_le,
    { rintros z ‚ü®z,rfl‚ü©,
      obtain ‚ü®z,rfl‚ü© := (prop819_degree_zero_helper _ surj) z,
      change ‚à• g.to_fun _ ‚à• ‚â§ _,
      erw ‚Üê LocallyConstant_map_apply M _ F.right (limits.wide_pullback.base (Œª i, F.hom)) g z,
      apply locally_constant.norm_apply_le },
    { rcases hh with ‚ü®x‚ü©,
      refine ‚ü®‚à• g.to_fun x ‚à•, x, rfl‚ü© },
    { use ‚à• g ‚à•,
      rintro y ‚ü®y,rfl‚ü©,
      dsimp,
      apply locally_constant.norm_apply_le } },
  { rw locally_constant_norm_empty _ _ hh g,
    simp }
end

theorem prop819_degree_zero (f : (FLC F M).X 0) (hf : (FLC F M).d 0 1 f = 0) :
  f = 0 :=
begin
  apply injective_of_strict_iso _ _ (FLC_iso F M) _ _ hf,
  intros f hf,
  have := @controlled_exactness ((FL F M).X 0) (0 : SemiNormedGroup) ((FL F M).X 1) _ _ _ 0 1
    zero_lt_one 1 ((FL F M).d _ _) _ _ f _ 1 zero_lt_one,
  { rcases this with ‚ü®g,h1,h2‚ü©,
    rw ‚Üê h1,
    simp },
  { intros g hg,
    refine ‚ü®0,_, by simp‚ü©,
    change (FL F M).d 0 1 g = 0 at hg,
    dsimp,
    symmetry,
    delta FL at hg,
    dsimp only [cosimplicial_object.augmented.whiskering,
      cosimplicial_object.augmented.whiskering_obj,
      cosimplicial_object.augmented.to_cocomplex,
      cochain_complex.of] at hg,
    rw dif_pos at hg,
    swap, {simp},
    dsimp [cosimplicial_object.augmented.to_cocomplex_d] at hg,
    simp only [locally_constant.comap_hom_apply, category.id_comp, category.comp_id] at hg,
    ext x,
    obtain ‚ü®x,rfl‚ü© := (prop819_degree_zero_helper F surj) x,
    apply_fun (Œª e, e x) at hg,
    dsimp [locally_constant.comap] at hg,
    split_ifs at hg,
    { exact hg },
    { exfalso, apply h, continuity },
    { exfalso, apply h, continuity } },
  { rintro g ‚ü®g,rfl‚ü©,
    refine ‚ü®g,rfl,_‚ü©,
    dsimp [cosimplicial_object.augmented.to_cocomplex_d],
    simp only [locally_constant.comap_hom_apply, one_mul,
      if_true, eq_self_iff_true, category.id_comp, category.comp_id],
    apply prop819_zero_norm_le _ surj },
  { exact hf }
end

theorem prop819 {m : ‚Ñï} (Œµ : ‚Ñù‚â•0) (hŒµ : 0 < Œµ)
  (f : (FLC F M).X (m+1)) (hf : (FLC F M).d (m+1) (m+2) f = 0) :
  ‚àÉ g : (FLC F M).X m, (FLC F M).d m (m+1) g = f ‚àß nnnorm g ‚â§ (1 + Œµ) * (nnnorm f) :=
begin
  apply exact_of_strict_iso _ _ (FLC_iso F M) Œµ hŒµ _ _ _ hf,
  apply cmpl_exact_of_exact _ _ hŒµ,
  clear hf f m hŒµ Œµ,
  intros n f hf,
  -- We've reduced to the non-completed case.
  sorry,
end
