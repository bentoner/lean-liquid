-- import category_theory.Fintype
-- import data.real.nnreal
-- import laurent_measures.basic
-- import order.filter.at_top_bot

-- /-
-- We define the map Œ∏ : (laurent_measures r `singleton`) ‚Üí ‚Ñù and we show it is surjective.
-- TO DO :
-- * Prove `lemma has_sum_pow_floor` and deduce `lemma has_sum_pow_floor_norm` from it
-- * Upgrade Œ∏ to a `comp_haus_blah` morphism
-- * Finish the proof of surjectivity for negative reals using linearity
-- -/

-- open filter function classical finset nat
-- open_locale topological_space classical nnreal big_operators

-- --move me to laurent_measures.basic



-- -- instance : has_coe (laurent_measures r S) (laurent_measures r‚ÇÅ S) :=
-- -- { coe :=
-- -- begin
-- --   rintros ‚ü®F, hF‚ü©,
-- --   use F,
-- --   by admit,
-- -- end}


-- section thm69_surjective

-- lemma sub_one_le_nat_floor' (x : ‚Ñù) : x - 1 ‚â§ ‚åäx‚åã‚Çä :=
-- begin
--   by_cases hx : x ‚â§ 0,
--   { rw (nat_floor_of_nonpos hx), exact (le_of_lt (sub_one_lt x)).trans hx },
--   { rw [sub_le_iff_le_add], exact le_of_lt (lt_nat_floor_add_one x) }
-- end

-- -- lemma nat_floor_le_nat (x : ‚Ñù‚â•0) : (‚åä(x.1)‚åã‚Çä : ‚Ñù‚â•0) ‚â§ x :=
-- --   by {simp only [‚Üê nnreal.coe_le_coe, nnreal.coe_nat_cast], from nat_floor_le x.2}

-- lemma converges_floor_rat  --(r' : ‚Ñù‚â•0) [fact (r' < 1)] (h_r' : r' ‚â† 0) :
--     (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (x : ‚Ñù) (h_x : x ‚â• 0)
--    : tendsto (Œªn : ‚Ñï, (nat_floor (x / r' ^ (n - 1)) : ‚Ñù) * r' ^ ( n- 1)) at_top (ùìù x) :=
-- begin
--   by_cases h_zero : x = 0,
--   { simp_rw [h_zero, zero_div, nat_floor_zero, nat.cast_zero, zero_mul, tendsto_const_nhds] },
--   { let x‚ÇÄ : ‚Ñù‚â•0 := ‚ü®x, h_x‚ü©,
--     have h_pos : ‚àÄ n : ‚Ñï, 0 < (r' : ‚Ñù) ^ n := pow_pos (rat.cast_pos.mpr h_pos'),
--     haveI : ‚àÄ n : ‚Ñï, invertible ((r' : ‚Ñù) ^ n) := Œª n, invertible_of_nonzero (ne_of_gt (h_pos n)),
--     have h‚ÇÅ : ‚àÄ n : ‚Ñï, (x - r' ^ (n - 1)) ‚â§ (nat_floor (x / r' ^ (n - 1)) : ‚Ñù) * r' ^ (n - 1),
--     { intro n,
--       have := (mul_le_mul_right $ h_pos (n -1)).mpr
--         (sub_one_le_nat_floor' (x / (r' : ‚Ñù) ^ (n - 1) : ‚Ñù)),
--       have h_calc : (x - r' ^ (n - 1)) = ( x / r' ^ (n - 1) - 1) * (r' ^ (n - 1)),
--       { rw [div_sub_one, div_mul_cancel];
--         apply ne_of_gt (h_pos (n - 1)) },
--       rwa h_calc },
--     have HH : tendsto (Œªn : ‚Ñï, x - r' ^ (n -1 )) at_top (ùìù x),
--     { suffices : tendsto (Œªn : ‚Ñï, (r' : ‚Ñù) ^ (n -1)) at_top (ùìù 0),
--       { have h_geom := tendsto.mul_const (-1 : ‚Ñù) this,
--         replace h_geom := tendsto.const_add x h_geom,
--         simp_rw [pi.add_apply, zero_mul, add_zero, mul_neg_one,
--           tactic.ring.add_neg_eq_sub] at h_geom,
--         exact h_geom },
--       have h_abs : abs (r' : ‚Ñù) < 1,
--       { norm_cast,
--         apply abs_lt.mpr,
--         exact and.intro ((right.neg_neg_iff.mpr (@zero_lt_one ‚Ñö _ _)).trans h_pos') h_one',
--         all_goals {apply_instance} },
--       replace h_abs := filter.tendsto.const_mul (r'‚Åª¬π : ‚Ñù)
--         (tendsto_pow_at_top_nhds_0_of_abs_lt_1 (h_abs)),
--       simp_rw [mul_zero, (mul_comm (r'‚Åª¬π : ‚Ñù) _)] at h_abs,
--       apply tendsto.congr' _ h_abs,
--       replace h_pos' : (r' : ‚Ñù) ‚â† 0 := by {rwa [ne.def, rat.cast_eq_zero], from (ne_of_gt h_pos')},
--       rw eventually_eq_iff_exists_mem,
--       use { n | n ‚â• 1 },
--       split,
--       { simp only [mem_at_top_sets, ge_iff_le, set.mem_set_of_eq],
--         use 1,
--         tauto },
--       { intros n hn,
--         field_simp,
--         ring_nf,
--         nth_rewrite_rhs 0 [‚Üê pow_one ‚Üër'],
--         rw [‚Üê pow_add ‚Üër' 1 (n - 1)],
--         rwa nat.add_sub_cancel' }},
--     have h‚ÇÇ : ‚àÄ n : ‚Ñï, (nat_floor (x / (r' : ‚Ñù) ^ (n - 1) ) : ‚Ñù) * (r' : ‚Ñù) ^ (n - 1) ‚â§ x,
--     { intro n,
--       have h_pos' : (x / r' ^ (n - 1)) > 0 := div_pos ((ne.symm h_zero).le_iff_lt.mp h_x) (h_pos (n - 1)),
--       have := (mul_le_mul_right $ h_pos (n - 1)).mpr (nat_floor_le (le_of_lt h_pos')),
--       calc (nat_floor (x / r' ^ (n - 1)) : ‚Ñù) * (r' : ‚Ñù) ^ (n - 1) ‚â§ (x / r' ^ (n - 1)) * (r' ^ (n - 1)) : this
--                                               ... = x : div_mul_cancel_of_invertible x (r' ^ (n - 1)) },
--     apply tendsto_of_tendsto_of_tendsto_of_le_of_le HH tendsto_const_nhds h‚ÇÅ h‚ÇÇ },
-- end

-- noncomputable  def floor_seq_rat (r' : ‚Ñö) (x : ‚Ñù) : ‚Ñ§ ‚Üí ‚Ñ§ --or ‚Üí ‚Ñ§?
-- | (int.of_nat n)          := if n = 0 then ‚åäx‚åã‚Çä else
--                                 ‚åä1 / (r' : ‚Ñù) ^ n * x‚åã‚Çä - ‚åä1 / r'‚åã‚Çä * ‚åä1 / (r' : ‚Ñù) ^ (n-1) * x‚åã‚Çä
-- | (int.neg_succ_of_nat n) := 0

-- noncomputable  def floor_seq_half (x : ‚Ñù) : ‚Ñ§ ‚Üí ‚Ñ§ --or ‚Üí ‚Ñ§?
-- | (int.of_nat n)          := if n = 0 then ‚åäx‚åã else ‚åä2 ^ n * x‚åã - 2 * ‚åä2 ^ (n - 1) * x‚åã
-- | (int.neg_succ_of_nat n) := 0


-- -- --move me to mathlib
-- lemma floor_mul_le_mul_floor (x : ‚Ñù) (n : ‚Ñï) : (n : ‚Ñ§) * ‚åäx‚åã ‚â§ ‚åä(n : ‚Ñù) * x‚åã :=
-- begin
--   have zero : (n : ‚Ñù) ‚â• 0, simp only [cast_nonneg, ge_iff_le],
--   have := lt_of_le_of_lt (mul_le_mul_of_nonneg_left (floor_le x) zero)
--     (lt_floor_add_one ((n : ‚Ñù) * x)),
--   norm_cast at this,
--   exact int.le_of_lt_add_one this,
-- end

-- lemma pos_floor_seq_half (x : ‚Ñù) (h_x : x ‚â• 0) (m : ‚Ñ§) : floor_seq_half x m ‚â• 0 :=
-- begin
--   induction m with m hm,
--   induction m with n h_ind generalizing x,
--   { simp only [int.coe_nat_zero, ge_iff_le, int.of_nat_eq_coe],
--     have : floor_seq_half x 0 = ‚åäx‚åã := rfl,
--     rw [this, ‚Üê (@floor_zero ‚Ñù _ _)],
--     exact floor_mono h_x },
--   { have case_one : ‚àÄ y : ‚Ñù, floor_seq_half y (int.of_nat 1) ‚â• 0,
--     { intro y,
--       simp,
--       have : floor_seq_half y 1 = ‚åä2 ^ 1 * y‚åã - 2 ^ 1 * ‚åä2 ^ (1 - 1) * y‚åã := rfl,
--       rw [this, nat.sub_self, pow_zero, pow_one, pow_one, one_mul],
--       have floor_mul_le := floor_mul_le_mul_floor y 2,
--       norm_cast at floor_mul_le,
--       linarith },
--     by_cases h_big : n = 0,
--     { rw h_big, exact case_one x },
--     { have : ‚àÄ x, ‚àÄ d : ‚Ñï, d ‚â• 1 ‚Üí floor_seq_half x (int.of_nat d) = ‚åä2 ^ d * x‚åã - 2 * ‚åä2 ^ (d - 1) * x‚åã,
--       { intros x d hd, exact if_neg (ne_of_gt (gt_of_ge_of_gt hd zero_lt_one)) },
--       rw this,
--       replace h_big : n ‚â• 1,
--       refine succ_le_iff.mpr (lt_of_le_of_ne (nat.zero_le n) (ne_comm.mp h_big)),
--       have spec_pow := this (2 ^ n * x) 1 (ge_of_eq rfl),
--       rw [pow_one, nat.sub_self, pow_zero, one_mul, ‚Üê mul_assoc] at spec_pow,
--       specialize this x n h_big,
--       rw succ_sub_one,
--       have aux‚ÇÅ : ‚åä2 ^ n.succ * x‚åã - 2 * ‚åä2 ^ n * x‚åã = ‚åä2 ^ (n + 1) * x‚åã - 2 * ‚åä2 ^ n * x‚åã :=
--         by {rw succ_eq_add_one},
--       rw aux‚ÇÅ,
--       have aux‚ÇÇ : ‚åä2 ^ (n + 1) * x‚åã - 2 * ‚åä2 ^ n * x‚åã = ‚åä2 * 2 ^ n * x‚åã - 2 * ‚åä2 ^ n * x‚åã,
--       { rw [pow_add, pow_one], nth_rewrite_lhs 1 [mul_comm] },
--       rw aux‚ÇÇ,
--       have h_pos : 2 ^ n * x  ‚â• 0 := by { apply mul_nonneg _ h_x, simp only [zero_le_one,
--         zero_le_bit0, pow_nonneg] },
--       specialize h_ind (2 ^ n * x) h_pos,
--       rw ‚Üê spec_pow,
--       exact case_one (2 ^ n * x),
--       exact (succ_le_succ n.zero_le) }},
--   { have : floor_seq_half x -[1+ hm] = 0 := rfl,
--     exact ge_of_eq this },
-- end

-- lemma pos_floor_seq_rat (r' : ‚Ñö) (x : ‚Ñù) (m : ‚Ñ§) : floor_seq_rat r' x m ‚â• 0 :=
-- begin
--   by_cases hm : m < 0,
--   refine le_of_eq _,
--   by admit,
--   lift m to ‚Ñï,
--   induction m with m h_ind,
--   { change (‚åäx‚åã‚Çä : ‚Ñ§) ‚â• 0,
--     simp only [ge_iff_le, int.coe_nat_nonneg]},
--   by admit, by admit,
-- end


-- lemma finite_sum_floor_seq_rat (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (x : ‚Ñù) (n : ‚Ñï) :
--   (range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_rat r' x) ‚Üëi * (r' : ‚Ñù) ^ i) =
--     if n = 0 then 0 else ‚åäx / r' ^ (n - 1) ‚åã‚Çä * r' ^ (n - 1) :=
-- begin
--   by admit,
-- end


-- --move me
-- lemma range_Ico_prepend (n : ‚Ñï) (h : 0 < n) : range n = insert 0 (Ico 1 n) :=
-- by {rw [‚Üê zero_add 1, range_eq_Ico], from (Ico.insert_succ_bot h).symm}

-- lemma finite_sum_floor_seq_half (x : ‚Ñù) (n : ‚Ñï) : --[fact (r' < 1)] (h_r' : r' > 0)
--   (range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_half x) ‚Üëi * (1 / 2 : ‚Ñù) ^ i) =
--     if n = 0 then 0 else ‚åäx / (1 / 2 : ‚Ñù) ^ (n - 1) ‚åã‚Çä * (1 / 2 : ‚Ñù) ^ (n - 1) :=
-- begin
--   by admit,
--   -- by_cases h_nz : n = 0, by admit,
--   -- rw if_neg h_nz,
--   -- have uno : (range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_half x) ‚Üëi * (1 / 2 : ‚Ñö) ^ i) =
--   --   ‚åäx‚åã‚Çä + ‚àë k in (Ico 1 n), (1 / 2 ^ (k : ‚Ñ§)) * (‚åä2 ^ (k : ‚Ñ§) * x‚åã‚Çä - 2 * ‚åä2 ^ ((k - 1) : ‚Ñ§) * x‚åã‚Çä),
--   -- rw [range_Ico_prepend, sum_insert],
--   -- congr' 1,
--   --   { rw [pow_zero, mul_one], refl },
--   --   { apply finset.sum_congr,
--   --     refl,
--   --     intros k hk,
--   --     induction k with k H_ind,by admit,
--   --     rw nat.succ_eq_add_one,
--   --     field_simp,
--   --     simp,



--   --     replace hk : k ‚â• 1, by admit,
--   --     field_simp,
--   --     suffices : floor_seq_half_temp x k = ‚åä2 ^ k * x‚åã‚Çä - 2 * ‚åä2 ^ (k - 1) * x‚åã‚Çä,
--   --     rw this,
--   --     simp only [int.cast_coe_nat, int.cast_bit0, int.cast_mul, int.cast_one, int.cast_sub,
--   --       gpow_coe_nat],by admit,


--   --     -- have try : floor_seq_half_temp x 0 = ‚åäx‚åã‚Çä, refl,
--   --     -- have try2 : floor_seq_half_temp x 1 = (‚åä2 ^ 1 * x‚åã‚Çä : ‚Ñ§) - 2 * (2 ^ (1 - 1) * ‚åäx‚åã‚Çä : ‚Ñ§),
--   --     convert if_neg hk,

--   --     -- replace hk : k ‚â† 0, by admit,
--   --     -- simp,
--   --     -- nth_rewrite 3 [‚Üê cast_one],
--   --     -- have mah : (k : ‚Ñ§) - (1 : ‚Ñ§) = ‚Üë(k - 1), by admit,
--   --     -- rw mah,

--   --     -- cases k,by admit,
--   --     -- simp,
--   --     -- simp,/
--   --     -- erw ‚Üê cast_sub hk,


--   --        },
-- end

-- -- lemma finite_sum_floor_seq_half‚ÇÅ (x : ‚Ñù) (n : ‚Ñï) : --[fact (r' < 1)] (h_r' : r' > 0)
-- --   (range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_rat (1 / 2 : ‚Ñö) x) ‚Üëi * (1 / 2 : ‚Ñù) ^ i) =
-- --     if n = 0 then 0 else ‚åäx / (1 / 2 : ‚Ñù) ^ (n - 1) ‚åã‚Çä * (1 / 2 : ‚Ñù) ^ (n - 1) :=
-- -- begin
-- --   by admit,
--   -- by_cases h_nz : n = 0, by admit,
--   -- rw if_neg h_nz,
--   -- have uno : (range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_rat (1 / 2 : ‚Ñö) x) ‚Üëi * (1 / 2 : ‚Ñö) ^ i) =
--   --   ‚åäx‚åã‚Çä + ‚àë k in (Ico 1 n), (1 / 2 ^ (k : ‚Ñ§)) * (‚åä2 ^ (k : ‚Ñ§) * x‚åã‚Çä - 2 * ‚åä2 ^ (k - 1 : ‚Ñ§) * x‚åã‚Çä),
--   -- { rw [range_Ico_prepend, sum_insert],
--   --   congr,
--   --   {rw [pow_zero, mul_one], refl },
--   --   funext k,
--   --   rw mul_comm,
--   --   rw div_pow,
--   --   rw one_pow,
--   --   rw ‚Üê gpow_coe_nat,
--   --   rw mul_eq_mul_left_iff,
--   --   apply or.intro_left,
--   --   field_simp,
--   --   --refl,
--   --   -- rw ‚Üê int.cast_id,
--   --   -- rw cast_mul,
--   --   -- simp,
--   --   -- norm_cast,
--   --   -- zify,
--   --   -- simp,

--   --   -- suffices : (floor_seq_rat (1 / 2 : ‚Ñö) x ‚Üëk) = (‚åä2 ^ (k : ‚Ñ§) * x‚åã‚Çä : ‚Ñ§) - ‚Üë2 * ‚Üë‚åä2 ^ (k - 1 : ‚Ñ§) * x‚åã‚Çä,
--   --   -- apply_fun (coe : ‚Ñ§ ‚Üí ‚Ñö) at this,
--   --   -- rw [int.cast_sub, int.cast_mul] at this,
--   --   -- rw this,
--   --   -- simp only [int.cast_coe_nat, int.cast_bit0, int.cast_one, gpow_coe_nat],
--   --   -- simp only [cast_one, cast_bit0],
--   --   -- rw gpow_coe_nat,
--   --   -- simp,
--   --   -- rw gpow_coe_nat,

--   --   -- rw int.cast_one,
--   --   -- rw nsmul_eq_gsmul,
--   --   -- rw ‚Üê int.nat_cast_eq_coe_nat,
--   --   -- rw [‚Üê cast_mul 2 ‚åä2 ^ (‚Üëk - 1) * x‚åã‚Çä],
--   --   -- refl,
--   --   conv_rhs
--   --   -- begin
--   --     {rw [‚Üê inv_inv‚ÇÄ (2 : ‚Ñù)],
--   --     rw norm_num.inv_div_one,
--   --     rw norm_num.inv_div_one,
--   --     rw [‚Üê inv_inv‚ÇÄ (2 : ‚Ñö)],
--   --     rw norm_num.inv_div_one,
--   --     rw norm_num.inv_div_one,},
--   --     norm_cast,
--   --     nth_rewrite 0 div_pow,
--   --     nth_rewrite 0 div_pow,
--   --     repeat {rw one_pow},
--   --     rw ‚Üê gpow_coe_nat,
--   --     have : 1 / (1 / 2 : ‚Ñö) = ‚åä 1 / (1 / 2 : ‚Ñö)‚åã‚Çä,by admit,
--   --     rw this,
--   --     refl,

--   --   -- end

--   --   -- nth_rewrite_rhs 0 [‚Üê inv_inv‚ÇÄ (2 : ‚Ñù)],
--   --   -- repeat {rw norm_num.inv_div_one},
--   --   -- nth_rewrite_rhs 0 [‚Üê inv_inv‚ÇÄ (2 : ‚Ñö)],
--   --   -- rw norm_num.inv_div_one,
--   --   -- nth_rewrite_rhs 0 [‚Üê inv_inv‚ÇÄ (2 : ‚Ñù)],
--   --   -- rw norm_num.inv_div_one,
--   --   -- rw norm_num.inv_div_one,
--   --   -- refl,
--   -- -- rfl,
--   -- -- obtain ‚ü®k, hk‚ü© := exists_eq_succ_of_ne_zero h_nz,
--   -- -- rw hk,
--   -- },
--   -- have due :=
--   -- calc  ‚åäx‚åã‚Çä + ‚àë k in (Ico 1 n), 1 / 2 * (‚åä2 ^ k * x‚åã‚Çä - 2 * ‚åä2 ^ (k - 1) * x‚åã‚Çä) =
--   --       ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * ‚àë k in (Ico 1 n), 2 ^ (n - k) * (‚åä2 ^ k * x‚åã‚Çä - 2 * ‚åä2 ^ (k - 1) * x‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * ( ‚àë k in (Ico 1 n), 2 ^ (n - k) * ‚åä2 ^ k * x‚åã‚Çä - ‚àë k in (Ico 1 n), 2 ^ (n - (k - 1)) * ‚åä2 ^ (k - 1) * x‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * (‚åä2 ^ (n - 1) * x‚åã‚Çä + ‚àë k in (Ico 1 (n - 1)), 2 ^ (n - k) * ‚åä2 ^ k * x‚åã‚Çä - ‚àë k in (Ico 1 n), 2 ^ (n - (k - 1)) * ‚åä2 ^ (k - 1) * x‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * (‚åä2 ^ (n - 1) * x‚åã‚Çä + ‚àë k in (Ico 1 (n - 1)), 2 ^ (n - k) * ‚åä2 ^ k * x‚åã‚Çä - ‚àë k in (Ico 2 n), 2 ^ (n - (k - 1)) * ‚åä2 ^ (k - 1) * x‚åã‚Çä - 2 ^ (n - 1) * ‚åäx‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * (‚åä2 ^ (n - 1) * x‚åã‚Çä + ‚àë k in (Ico 1 (n - 1)), 2 ^ (n - k) * ‚åä2 ^ k * x‚åã‚Çä - ‚àë k in (Ico 1 (n - 1)), 2 ^ (n - k) * ‚åä2 ^ k * x‚åã‚Çä - 2 ^ (n - 1) * ‚åäx‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * (‚åä2 ^ (n - 1) * x‚åã‚Çä - 2 ^ (n - 1) * ‚åäx‚åã‚Çä) : by admit
--   -- ... = ‚åäx‚åã‚Çä + 1 / 2 ^ (n - 1) * ‚åä2 ^ (n - 1) * x‚åã‚Çä - (1 / 2 ) ^ (n - 1) * 2 ^ (n - 1) * ‚åäx‚åã‚Çä : by admit
--   -- ... = 1 / 2 ^ (n - 1) * ‚åä2 ^ (n - 1) * x‚åã‚Çä : by admit,
--   --   --  by admit,/
--   --   by admit,
-- -- end

-- lemma has_sum_pow_floor_rat (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (x : ‚Ñù) (h_x : x‚â•0)
--   : has_sum (Œª n, (coe ‚àò floor_seq_rat r' x) n * (r' : ‚Ñù) ^ n) x :=
-- begin
--   let x‚ÇÄ : ‚Ñù‚â•0 := ‚ü®x, h_x‚ü©,
--   have hinj : function.injective (coe : ‚Ñï ‚Üí ‚Ñ§) := by {apply int.coe_nat_inj},
--   have h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí floor_seq_rat r' x n = 0,
--   { intro,
--     cases n,
--     simp only [forall_false_left, set.mem_range_self, not_true, int.of_nat_eq_coe],
--     intro,
--     refl },
--   replace h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí
--     (coe ‚àò floor_seq_rat r' x) n * (r' : ‚Ñù) ^ n = 0,
--   { intros n hn,
--     specialize h_range n hn,
--     rw [comp_app, h_range, int.cast_zero, zero_mul], },
--     -- rw [comp_app, h_range, nat.cast_zero, zero_mul], },--for the ‚Ñï-valued version of floor_seq_rat
--   apply (@function.injective.has_sum_iff _ _ _ _ _ _ x _ hinj h_range).mp,
--   have H : (Œª (n : ‚Ñ§), ((coe ‚àò floor_seq_rat r' x) n * (r' : ‚Ñù) ^ n)) ‚àò coe =
--     (Œª (n : ‚Ñï), (coe ‚àò floor_seq_rat r' x) n * r' ^ n) := by {funext,--want to change  (r' : ‚Ñù) ^ n?
--       simp only [comp_app, gpow_coe_nat] },
--   rw H,
--   have h_pos : ‚àÄ n : ‚Ñï, (coe ‚àò floor_seq_rat r' x) n * (r' : ‚Ñù) ^ n ‚â• 0,
--   { intro n,
--     apply mul_nonneg,
--     rw comp_app,
--     simp only [int.cast_nonneg],
--     exact pos_floor_seq_rat r' x n,--remove for ‚Ñï-val'd floor_seq_rat
--     -- simp only [nat.cast_nonneg],-- for ‚Ñï-val'd floor_seq_rat
--     norm_cast,
--     apply pow_nonneg (le_of_lt h_pos') n, },
--   apply (has_sum_iff_tendsto_nat_of_nonneg h_pos x).mpr,
--   have aux : (Œª n, ite (n = 0) (0 : ‚Ñù) ((‚åäx / (r' : ‚Ñù) ^ (n - 1)‚åã‚Çä) * (r' : ‚Ñù) ^ (n - 1))) =·∂†[at_top]
--     Œª n, (‚Üë‚åäx / (r' : ‚Ñù) ^ (n - 1)‚åã‚Çä * (r' : ‚Ñù) ^ (n - 1)),
--   { rw eventually_eq_iff_exists_mem,
--     use { n | n ‚â• 1 },
--     split,
--     { simp only [mem_at_top_sets, ge_iff_le, set.mem_set_of_eq],
--       use 1,
--       tauto },
--     { intros n hn,
--       replace hn : n ‚â† 0 := ne_of_gt (nat.succ_le_iff.mp hn),
--       simpa only [ite_eq_right_iff, nat.cast_eq_zero, zero_eq_mul] }},
--   simp_rw (finite_sum_floor_seq_rat r' h_pos' h_one' x),
--   rw ‚Üê (tendsto_congr' aux.symm),
--   apply converges_floor_rat r' h_pos' h_one' x h_x,
-- end

-- lemma has_sum_pow_floor_half (x : ‚Ñù) (h_x : x‚â•0) :
--   has_sum (Œª n, (coe ‚àò floor_seq_half x) n * ((1 / 2) : ‚Ñù) ^ n) x :=
-- begin
--   -- have h_pos' := (@one_half_pos ‚Ñù _),
--   let x‚ÇÄ : ‚Ñù‚â•0 := ‚ü®x, h_x‚ü©,
--   have hinj : function.injective (coe : ‚Ñï ‚Üí ‚Ñ§) := by {apply int.coe_nat_inj},
--   have h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí floor_seq_half x n = 0,
--   { intro,
--     cases n,
--     simp only [forall_false_left, set.mem_range_self, not_true, int.of_nat_eq_coe],
--     intro,
--     refl },
--   replace h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí
--     (coe ‚àò floor_seq_half x) n * ((1 / 2) : ‚Ñù) ^ n = 0,
--   { intros n hn,
--     specialize h_range n hn,
--     rw [comp_app, h_range, int.cast_zero, zero_mul], },
--     -- rw [comp_app, h_range, nat.cast_zero, zero_mul], },
--   apply (@function.injective.has_sum_iff _ _ _ _ _ _ x _ hinj h_range).mp,
--   have H : (Œª (n : ‚Ñ§), ((coe ‚àò floor_seq_half x) n * ((1 / 2) : ‚Ñù) ^ n)) ‚àò coe =
--     (Œª (n : ‚Ñï), (coe ‚àò floor_seq_half x) n * (1 / 2) ^ n) := by {funext,--want to change  (r' : ‚Ñù) ^ n?
--       simp only [comp_app, gpow_coe_nat] },
--   rw H,
--   have h_pos : ‚àÄ n : ‚Ñï, (coe ‚àò floor_seq_half x) n * ((1 / 2) : ‚Ñù) ^ n ‚â• 0,
--   { intro n,
--     apply mul_nonneg,
--     rw comp_app,
--     -- simp only [nat.cast_nonneg],-- for ‚Ñï-val'd floor_seq_rat
--     norm_cast,
--     exact (pos_floor_seq_half x h_x n),--remove -- for ‚Ñï-val'd floor_seq_rat
--     apply pow_nonneg (le_of_lt (@one_half_pos ‚Ñù _)) n },
--   apply (has_sum_iff_tendsto_nat_of_nonneg h_pos x).mpr,
--   have aux : (Œª n, ite (n = 0) (0 : ‚Ñù) ((‚åäx / ((1 / 2) : ‚Ñù) ^ (n - 1)‚åã‚Çä) * ((1 / 2) : ‚Ñù) ^ (n - 1)))
--    =·∂†[at_top] Œª n, (‚Üë‚åäx / ((1 / 2) : ‚Ñù) ^ (n - 1)‚åã‚Çä * ((1 / 2) : ‚Ñù) ^ (n - 1)),
--   { rw eventually_eq_iff_exists_mem,
--     use { n | n ‚â• 1 },
--     split,
--     { simp only [mem_at_top_sets, ge_iff_le, set.mem_set_of_eq],
--       use 1,
--       tauto },
--     { intros n hn,
--       replace hn : n ‚â† 0 := ne_of_gt (nat.succ_le_iff.mp hn),
--       simpa only [ite_eq_right_iff, nat.cast_eq_zero, zero_eq_mul] }},
--   simp_rw (finite_sum_floor_seq_half x),
--   rw ‚Üê (tendsto_congr' aux.symm),
--   convert converges_floor_rat (1 / 2 : ‚Ñö) (@one_half_pos ‚Ñö _) (one_half_lt_one) x h_x,
--   simp only [one_div, rat.cast_inv, rat.cast_one, rat.cast_bit0],
-- end


-- lemma has_sum_pow_floor_rat_norm (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (x : ‚Ñù) (h_x : x‚â•0) :
--   has_sum (Œª n, ‚à• (floor_seq_rat r' x n : ‚Ñù) ‚à• * r' ^ n) x :=
-- begin
--   by admit,--will be an easy consequence of the previous one
-- end

-- def laurent_measures.to_Rfct (r : ‚Ñù‚â•0) [fact (r < 1)] :
--   (laurent_measures r (Fintype.of punit)) ‚Üí (‚Ñ§ ‚Üí ‚Ñù) := Œª ‚ü®F, _‚ü©, coe ‚àò (F punit.star)

-- noncomputable def Œ∏ (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (r : ‚Ñù‚â•0) [fact (r < 1)] :
--  (laurent_measures r (Fintype.of punit)) ‚Üí ‚Ñù := Œª F, tsum (Œª n, (F.to_Rfct r n) * r' ^ n)

-- -- noncomputable def Œ∏‚ÇÇ (r : ‚Ñù‚â•0) [fact (r < 1)] : (laurent_measures r (Fintype.of punit)) ‚Üí ‚Ñù :=
-- --   Œª F, tsum (Œª n, (F.to_Rfct r n) * ( 1 / 2) ^ n)


-- --[FAE] : modify œï to a `def` and do things properly!
-- def œï (r‚ÇÇ r‚ÇÅ : ‚Ñù‚â•0) (h : r‚ÇÅ < r‚ÇÇ) {S : Fintype} :
--   (laurent_measures r‚ÇÇ S) ‚Üí (laurent_measures r‚ÇÅ S) := by admit


-- lemma Œ∏_and_œï (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) (r‚ÇÅ r‚ÇÇ : ‚Ñù‚â•0) [fact (r‚ÇÅ < 1)]
--   [fact (r‚ÇÇ < 1)] (h : r‚ÇÅ < r‚ÇÇ) (F : laurent_measures r‚ÇÇ (Fintype.of punit)) :
--   Œ∏ r' h_pos' h_one' r‚ÇÅ (œï r‚ÇÇ r‚ÇÅ h F) = Œ∏ r' h_pos' h_one' r‚ÇÇ F := by admit

-- -- lemma Œ∏_and_œï‚ÇÇ (r‚ÇÅ r‚ÇÇ : ‚Ñù‚â•0) [fact (r‚ÇÅ < 1)] [fact (r‚ÇÇ < 1)] (h : r‚ÇÅ < r‚ÇÇ)
-- --   (F : laurent_measures r‚ÇÇ (Fintype.of punit)) : Œ∏‚ÇÇ r‚ÇÅ (œï r‚ÇÇ r‚ÇÅ h F) = Œ∏‚ÇÇ r‚ÇÇ F := by admit


-- --move me to mathlib
-- @[simp, norm_cast]
-- lemma coe_pow' (r : ‚Ñù‚â•0) (n : ‚Ñ§) : ((r^n : ‚Ñù‚â•0) : ‚Ñù) = r^n :=
-- begin
--   cases n,
--   apply nnreal.coe_pow,
--   simp only [gpow_neg_succ_of_nat, inv_pow', nnreal.coe_pow, nnreal.coe_inv],
-- end


-- lemma aux_surj (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) --(r : ‚Ñù‚â•0) [fact (r < 1)]
--   (t : ‚Ñö) (h_pos : 0 < t)
--   [H : fact ((‚ü®(t : ‚Ñù), le_of_lt ((@rat.cast_pos ‚Ñù _ _).mpr h_pos)‚ü© : ‚Ñù‚â•0) < (1 : ‚Ñù‚â•0))]
--   (h_r't : r' < t) (x : ‚Ñù) (h_x : x‚â•0) :
--   ‚àÉ (F : laurent_measures ‚ü®(t : ‚Ñù), le_of_lt ((@rat.cast_pos ‚Ñù _ _).mpr h_pos)‚ü© (Fintype.of punit)),
--   (@Œ∏ r' h_pos' h_one' ‚ü®(t : ‚Ñù), le_of_lt ((@rat.cast_pos ‚Ñù _ _).mpr h_pos)‚ü© H F) = x :=
-- begin
--   let t‚ÇÄ : ‚Ñù‚â•0 := (‚ü®(t : ‚Ñù), le_of_lt ((@rat.cast_pos ‚Ñù _ _).mpr h_pos)‚ü©),
--   have h_one : t‚ÇÄ < (1 : ‚Ñù‚â•0) := H.out,
--   replace h_one : t < 1 := by {apply (@rat.cast_lt ‚Ñù _ _ _).mp, rw rat.cast_one, exact h_one},
--   let F‚ÇÄ : Fintype.of punit ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª _ n, floor_seq_rat t x n,
--   -- let F‚ÇÄ : Fintype.of punit ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª _ n, int.of_nat (floor_seq_rat t x n),-- for ‚Ñï-val'd floor_seq_rat
--   have hF : ‚àÄ (s : Fintype.of punit), summable (Œª n : ‚Ñ§, ‚à• F‚ÇÄ s n ‚à• * t ^ n),
--   { intro s,
--     apply has_sum.summable (has_sum_pow_floor_rat_norm t h_pos h_one x h_x) },
--   let F : laurent_measures t‚ÇÄ (Fintype.of punit) := ‚ü®F‚ÇÄ, hF‚ü©,
--   use F,
--   have h_sum : summable (Œª (n : ‚Ñ§), (@laurent_measures.to_Rfct t‚ÇÄ H F n) * t ^ n) :=
--     (has_sum_pow_floor_rat t h_pos h_one x h_x).summable,
--   unfold Œ∏,
--   have := has_sum_pow_floor_rat r' h_pos' h_one' x h_x,
--   by admit,--FAE: We need somewhere to pass from convergence for t to convergence for r' < t
--   -- exact has_sum.tsum_eq this,
-- end


-- noncomputable def œÑ (r : ‚Ñù‚â•0) [fact (r < 1)] : {t : ‚Ñö // 0 < t} :=
-- begin
--   have h : r < 1 := fact.out _,
--   use some (@exists_rat_btwn ‚Ñù _ _ r 1 h),
--   rwa [‚Üê (@rat.cast_lt ‚Ñù _ 0 (some _)), rat.cast_zero],
--   exact (lt_of_le_of_lt r.2) (some_spec (@exists_rat_btwn ‚Ñù _ _ r 1 h)).left,
-- end

-- noncomputable def œÑ‚ÇÄ (r : ‚Ñù‚â•0) [fact (r < 1)] : ‚Ñù‚â•0 :=
-- ‚ü®((œÑ r).1 : ‚Ñù), le_of_lt ((@rat.cast_pos ‚Ñù _ _).mpr (œÑ r).2)‚ü©

-- lemma r'_lt_œÑ (r' : ‚Ñö) (r : ‚Ñù‚â•0) [fact (r < 1)] : r' < œÑ r := by admit

-- lemma œÑ‚ÇÄ_one (r' : ‚Ñö) (r : ‚Ñù‚â•0) [fact (r < 1)] : (œÑ‚ÇÄ r) < (1 : ‚Ñù‚â•0) := by admit

-- lemma r_lt_œÑ‚ÇÄ (r' : ‚Ñö) (r : ‚Ñù‚â•0) [fact (r < 1)] : r < (œÑ‚ÇÄ r) := by admit

-- lemma Œ∏_surj_on_nonneg_rat (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) --(r : ‚Ñù‚â•0) [fact (r < 1)]
--   (r : ‚Ñù‚â•0) (h_pos : 0 < r) [fact (r < 1)] (h_r'r : (r' : ‚Ñù) < r)
--   (x : ‚Ñù) (h_x : x‚â•0) : ‚àÉ (F : laurent_measures r (Fintype.of punit)),
--   (Œ∏ r' h_pos' h_one' r F) = x :=
-- begin
--   have H : fact (œÑ‚ÇÄ r < (1 : ‚Ñù‚â•0)) := ‚ü®œÑ‚ÇÄ_one r' r‚ü©,
--   obtain ‚ü®F, hF‚ü© := @aux_surj r' h_pos' h_one' (œÑ r) (œÑ r).2 H (r'_lt_œÑ r' r) x h_x,
--   use œï (œÑ‚ÇÄ r) r (r_lt_œÑ‚ÇÄ r' r) F,
--   have := @Œ∏_and_œï r' h_pos' h_one' r (œÑ‚ÇÄ r) _ H (r_lt_œÑ‚ÇÄ r' r) F,
--   rwa this,
-- end

-- -- lemma Œ∏_surj_on_nonneg_half (r : ‚Ñù‚â•0) (h_pos : 0 < r) [fact (r < 1)] (h_r' : (1 / 2 : ‚Ñù) < r)
-- --   (x : ‚Ñù) (h_x : x‚â•0) : ‚àÉ (F : laurent_measures r (Fintype.of punit)),
-- --   (Œ∏‚ÇÇ r F) = x := by admit
-- -- begin
--     by admit
-- --   have H : fact (œÑ‚ÇÄ r < (1 : ‚Ñù‚â•0)) := ‚ü®œÑ‚ÇÄ_one r‚ü©,
-- --   obtain ‚ü®F, hF‚ü© := @aux_surj r' h_pos' h_one' (œÑ r) (œÑ r).2 H (r'_lt_œÑ r' r) x h_x,
-- --   use œï (œÑ‚ÇÄ r) r (r_lt_œÑ‚ÇÄ r' r) F,
-- --   have := @Œ∏_and_œï r' h_pos' h_one' r (œÑ‚ÇÄ r) _ H (r_lt_œÑ‚ÇÄ r' r) F,
-- --   rwa this,
-- -- end


-- /--This is the version that I will probably be able to prove. I would also like to turn h_r' and
-- h_r into facts rather than being hypothesis.-/
-- theorem Œ∏_surj_rat (r' : ‚Ñö) (h_pos' : 0 < r') (h_one' : r' < 1) --(r : ‚Ñù‚â•0) [fact (r < 1)]
--   (r : ‚Ñù‚â•0) (h_pos : 0 < r) [fact (r < 1)] (h_r'r : (r' : ‚Ñù) < r)
--   (x : ‚Ñù) : ‚àÉ (F : laurent_measures r (Fintype.of punit)), (Œ∏ r' h_pos' h_one' r F) = x :=
-- begin
--   by_cases h_x : 0 ‚â§ x,
--   { exact (Œ∏_surj_on_nonneg_rat r' h_pos' h_one' r h_pos h_r'r x h_x)},
--   replace h_x := le_of_lt (neg_pos_of_neg (lt_of_not_ge h_x)),
--   obtain ‚ü®F, hF‚ü© := Œ∏_surj_on_nonneg_rat r' h_pos' h_one' r h_pos h_r'r (-x) h_x,
--   use -F,
--   by admit,--better to do it later, once Œ∏ becomes a comp_haus_blah morphism, in particular linear
-- end

-- end thm69_surjective

-- /--
-- p' ‚Üí (1/m)^p' < 1/2 ‚Üí , m must be larger than 2^(p'‚Åª¬π).


-- S : Fintype
-- r p': ‚Ñù‚â•0
-- h : (1 / 2) ^ p' = r

-- * f : laurent_measures r S ‚Üí laurent_measures r S := Œª F, (T‚Åª¬π - 2) * F
-- ``build it by hand as additive group hom' (+ comp_haus_bla)``

-- * g : laurent_measures r S ‚Üí real_measures p' S := Œª F s, Œ∏ (1 / 2) r F s
-- ``add group hom (+ comp_haus_bla)``

-- * They fit into a SES **GOAL**
-- 0 ‚Üí laurent_measures r S -f‚Üí laurent_measures -g‚Üí real_measures p' ‚Üí 0
-- as comp_haus_filt bla

-- * HOPE: Functor taking a comp_has_filt to cond_Ab is exact; get a SES in cond_Ab to put into
-- Ext and to get a LES of Ext groups whose terms are almost all 0 (i.e. for i ‚â• 1)

-- -/



-- ------------------------------------

-- -- lemma converges_floor_nat (x : ‚Ñù‚â•0) (r' : ‚Ñù‚â•0) [fact (r' < 1)] --[fact (r'.1 ‚â† 0)]
-- --   (h_nz : r' ‚â† 0) : tendsto (Œªn : ‚Ñï, (nat_floor (x.1 / r'.1 ^ n) : ‚Ñù‚â•0) * r' ^ n) at_top (ùìù x) :=
-- -- begin
-- --   by_cases hx : x = 0,
-- --   { simp_rw [hx, nnreal.val_eq_coe, nnreal.coe_zero, zero_div, nat_floor_zero, nat.cast_zero,
-- --       zero_mul, tendsto_const_nhds] },
-- --   { haveI : ‚àÄ n : ‚Ñï, invertible (r' ^ n) := Œª n, invertible_of_nonzero (pow_ne_zero n _),
-- --     have h_pos : ‚àÄ n : ‚Ñï,  0 < (r' ^ n) := Œª n, pow_pos ((ne.symm h_nz).le_iff_lt.mp r'.2) n,
-- --     replace hx : ‚àÄ n : ‚Ñï, x / r' ^ n ‚â† 0 := Œª n, div_ne_zero hx (ne_of_gt (h_pos n)),
-- --     have h‚ÇÅ : ‚àÄ n : ‚Ñï, (x - r' ^ n) ‚â§ (nat_floor (x.1 / r'.1 ^ n) : ‚Ñù‚â•0) * r' ^ n,
-- --     { intro n,
-- --       have := (mul_le_mul_right $ h_pos n).mpr (sub_one_le_nat_floor (x / r' ^ n) (hx n)),
-- --       rw [nnreal.val_eq_coe, nnreal.coe_div, nnreal.coe_pow] at this,
-- --       calc (x - r' ^ n)  = ( x / r' ^ n - 1) * (r' ^ n) : by by admit
-- --                     ... ‚â§ (nat_floor ( x.1 / r'.1 ^ n) * (r' ^ n)) : this },
-- --     have HH : tendsto (Œªn : ‚Ñï, x - r' ^ n) at_top (ùìù x),
-- --     { suffices : tendsto (Œªn : ‚Ñï, r'.1 ^ n) at_top (ùìù 0),
-- --       { have h_geom := tendsto.mul_const (-1 : ‚Ñù) this,
-- --         replace h_geom := tendsto.const_add x.1 h_geom,
-- --         simp_rw [pi.add_apply, zero_mul, add_zero, mul_neg_one,
-- --           tactic.ring.add_neg_eq_sub, nnreal.val_eq_coe] at h_geom,
-- --         apply nnreal.tendsto_coe.mp,
-- --         by admit,
-- --         -- simp_rw [‚Üê nnreal.coe_pow, ‚Üê nnreal.coe_sub] at h_geom,
-- --         -- convert h_geom -> bad idea!
-- --         },
-- --       have h_abs : abs r'.1 < 1 := by {simp, norm_cast, from fact.out _},
-- --       replace h_abs := tendsto_pow_at_top_nhds_0_of_abs_lt_1 (h_abs),
-- --       simp_rw [‚Üê one_div_pow],
-- --       exact h_abs },
-- --     have h‚ÇÇ : ‚àÄ n : ‚Ñï, (nat_floor ((x : ‚Ñù) / r' ^ n ): ‚Ñù‚â•0) * (r' ^ n) ‚â§ x,
-- --     { intro n,
-- --       have := (mul_le_mul_right $ h_pos n).mpr (nat_floor_le_nat (x / r' ^ n)),
-- --       rw [nnreal.val_eq_coe, nnreal.coe_div, nnreal.coe_pow] at this,
-- --       calc (nat_floor (x.1 / r'.1 ^ n) : ‚Ñù‚â•0) * (r' ^ n) ‚â§ (x / r' ^ n) * (r' ^ n) : this
-- --                                           ... = x : div_mul_cancel_of_invertible x (r' ^ n) },
-- --     apply tendsto_of_tendsto_of_tendsto_of_le_of_le HH tendsto_const_nhds h‚ÇÅ h‚ÇÇ,
-- --     simpa only [nnreal.val_eq_coe, nnreal.coe_eq_zero, ne.def, not_false_iff], },
-- -- end

-- lemma converges_floor (x : ‚Ñù‚â•0) :
--   tendsto (Œªn : ‚Ñï, (floor (2 ^ n * x : ‚Ñù) / (2 ^ n) : ‚Ñù)) at_top (ùìù x) :=
-- begin
--   have two_pow_pos : ‚àÄ n : ‚Ñï,  0 < (2 ^ n : ‚Ñù) := by simp only
--     [forall_const, zero_lt_bit0, pow_pos, zero_lt_one],
--   have h‚ÇÅ : ‚àÄ n : ‚Ñï, (x.1 - 1 / 2 ^ n) ‚â§ (floor (2 ^ n * x : ‚Ñù) / (2 ^ n) : ‚Ñù),
--   { intro n,
--     have := (div_le_div_right $ two_pow_pos n).mpr (le_of_lt (sub_one_lt_floor (2 ^ n * x.1))),
--     calc (x.1 - 1 / 2 ^ n) = ( 2 ^ n * x.1 - 1)/ 2 ^ n : by field_simp[mul_comm]
--                        ... ‚â§ (floor (2 ^ n * x.1) / (2 ^ n)) : this },
--   have HH : tendsto (Œªn : ‚Ñï, (x.1 - 1 / 2 ^ n)) at_top (ùìù x),
--   { suffices : tendsto (Œªn : ‚Ñï, (1 / 2 ^ n : ‚Ñù)) at_top (ùìù 0),
--     { have h_geom := tendsto.mul_const (-1 : ‚Ñù) this,
--       replace h_geom := tendsto.const_add x.1 h_geom,
--       simp_rw [pi.add_apply, zero_mul, add_zero, mul_neg_one] at h_geom,
--       exact h_geom },
--     have abs_half : abs ((1:‚Ñù)/2) < 1 := by {rw [abs_div, abs_one, abs_two], exact one_half_lt_one},
--     have mah := tendsto_pow_at_top_nhds_0_of_abs_lt_1 (abs_half),
--     simp_rw [‚Üê one_div_pow],
--     exact mah },
--   have h‚ÇÇ : ‚àÄ n : ‚Ñï, ((floor (2 ^ n * x.1) ) / (2 ^ n) : ‚Ñù) ‚â§ x.1,
--   { intro n,
--     have := (div_le_div_right $ two_pow_pos n).mpr (floor_le (2 ^ n * x.1)),
--     calc (floor (2 ^ n * x.1) / 2 ^ n : ‚Ñù)  ‚â§ (2 ^ n * x.1 / 2 ^ n) : this
--                                         ... = (x.1 * 2 ^ n / 2 ^ n) : by simp only [mul_comm]
--                                         ... = x.1 : by simp only [mul_div_cancel_of_invertible] },
--   apply tendsto_of_tendsto_of_tendsto_of_le_of_le HH tendsto_const_nhds h‚ÇÅ h‚ÇÇ,
-- end

-- noncomputable def floor_seq (x : ‚Ñù‚â•0): ‚Ñ§ ‚Üí ‚Ñ§
-- | (int.of_nat n)          := nat.rec_on n
--                           (floor x.1) (Œª n, floor (2 ^ n * x.1) - 2 * floor (2 ^ (n-1) * x.1))
-- | (int.neg_succ_of_nat n) := 0

-- noncomputable  def floor_seq_nat (x : ‚Ñù‚â•0): ‚Ñ§ ‚Üí ‚Ñï
-- | (int.of_nat n)          := nat.rec_on n
--                           (nat_floor x.1) (Œª n, nat_floor (2 ^ n * x.1) - 2 * nat_floor (2 ^ (n-1) * x.1))
-- | (int.neg_succ_of_nat n) := 0

-- lemma sub_one_le_nat_floor (x : ‚Ñù‚â•0) (hx : x ‚â† 0) : x - 1 ‚â§ ‚åäx.1‚åã‚Çä :=
-- begin
--   by_cases h_one : x.1 - 1 ‚â§ 0,
--   { have : x - 1 = 0 := real.to_nnreal_eq_zero.mpr h_one,
--     rw this,
--     exact zero_le ‚åäx.1‚åã‚Çä },
--   { simp only [‚Üê nnreal.coe_le_coe],
--     rw [nnreal.coe_sub, sub_le_iff_le_add, nnreal.coe_nat_cast],
--     all_goals { simp only [not_le, zero_add, nnreal.val_eq_coe] at h_one,
--       rw [lt_sub_iff_add_lt, zero_add] at h_one, apply le_of_lt },
--     exacts [(lt_nat_floor_add_one x.1), h_one] }
-- end

-- -- example {f : ‚Ñï ‚Üí ‚Ñù} {r : ‚Ñù} [h : r‚â•0] :
-- --   has_sum f r ‚Üî tendsto (Œªn:‚Ñï, ‚àë i in finset.range n, f i) at_top (ùìù r) := by library_search


-- -- lemma has_sum_pow_floor_nat (r' : ‚Ñù‚â•0) [fact (r' < 1)] (h_r' : r' ‚â† 0) (x : ‚Ñù‚â•0)
-- --   : has_sum (Œª n, (coe ‚àò floor_seq_nat x) n * r' ^ n) x :=
-- -- begin
-- --   have hinj : function.injective (coe : ‚Ñï ‚Üí ‚Ñ§) := by {apply int.coe_nat_inj},
-- --   have h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí floor_seq_nat x n = 0, by admit,
-- --   replace h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí (coe ‚àò floor_seq_nat x) n * r' ^ n = 0,
-- --   by admit,
-- --   apply (@function.injective.has_sum_iff _ _ _ _ _ _ x _ hinj h_range).mp,
-- --   have H : (Œª (n : ‚Ñ§), (coe ‚àò floor_seq_nat x) n * r' ^ n) ‚àò coe =
-- --     (Œª (n : ‚Ñï), (coe ‚àò floor_seq_nat x) n * r' ^ n), by admit,
-- --   rw H,
-- --   apply (nnreal.has_sum_iff_tendsto_nat).mpr,
-- --   have h_calc : ‚àÄ n : ‚Ñï,
-- --   (finset.range n).sum (Œª (i : ‚Ñï), (coe ‚àò floor_seq_nat x) ‚Üëi * r' ^ i) =
-- --     nat_floor (x.1 / r'.1 ^ n) * r' ^ n,
-- --      by admit,
-- --   simp_rw h_calc,
-- --   -- by admit,
-- --   apply converges_floor_nat x r' h_r',
-- -- end

-- -- lemma Œ∏_surj_on_nonneg (r' : ‚Ñù‚â•0) [fact (r' < 1)] (r : ‚Ñù‚â•0) [fact (r < 1)] (x : ‚Ñù‚â•0) :
-- --   ‚àÉ (F : laurent_measures r (Fintype.of punit)), (Œ∏ r' r F) = x :=
-- -- begin
-- --   let F‚ÇÄ : Fintype.of punit ‚Üí ‚Ñ§ ‚Üí ‚Ñ§ := Œª a, (floor_seq x),
-- --   have Hr : ‚àÄ (s : Fintype.of punit), summable (Œª (n : ‚Ñ§), ‚à•F‚ÇÄ s n‚à• * ‚Üër ^ n),
-- --   { intro s,
-- --     apply has_sum.summable (has_sum_pow_floor_norm r x) },
-- --   let F : laurent_measures r (Fintype.of punit) := ‚ü®F‚ÇÄ, Hr‚ü©,
-- --   use F,
-- --   have : summable (Œª (n : ‚Ñ§), (F.to_Rfct r n) * (r'.1) ^ n) :=
-- --     has_sum.summable (has_sum_pow_floor r' x),
-- --   unfold Œ∏,
-- --   unfold tsum,
-- --   rw [dif_pos this],
-- --   exact has_sum.unique (some_spec this) (has_sum_pow_floor r' x),
-- -- end




-- -- lemma has_sum_pow_floor (r' : ‚Ñù‚â•0) [fact (r' < 1)] (x : ‚Ñù‚â•0) :
-- --   has_sum (Œª n, (coe ‚àò floor_seq x) n * r'.1 ^ n) x :=
-- -- begin
-- --   -- apply (has_sum_iff_tendsto_nat_of_nonneg).mp,
-- --   have hinj : function.injective (coe : ‚Ñï ‚Üí ‚Ñ§) := by {apply int.coe_nat_inj},
-- --   have h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí floor_seq x n = 0, by admit,
-- --   replace h_range : ‚àÄ n : ‚Ñ§, n ‚àâ set.range (coe : ‚Ñï ‚Üí ‚Ñ§) ‚Üí (coe ‚àò floor_seq x) n * r'.1 ^ n = 0,
-- --   by admit,
-- --   apply (@function.injective.has_sum_iff _ _ _ _ _ _ x.1 _ hinj h_range).mp,
-- --   have H : (Œª (n : ‚Ñ§), (coe ‚àò floor_seq x) n * r'.val ^ n) ‚àò coe =
-- --     (Œª (n : ‚Ñï), (coe ‚àò floor_seq x) n * r'.val ^ n), by admit,
-- --   rw H,
-- --   by admit,
-- --   -- apply (nnreal.has_sum_iff_tendsto_nat).mpr,
-- -- --   funext a,
-- -- --   simp only [function.comp_app, gpow_coe_nat],
-- -- --   suffices : œÜ a = 1,
-- -- --   rw [this, one_mul],
-- -- --   refl,
-- -- --   rw H,
-- --   -- dsimp [has_sum],
-- --   -- apply summable.has_sum_iff_tendsto_nat,
-- -- end

-- -- lemma has_sum_pow_floor_norm (r : ‚Ñù‚â•0)  [fact (r < 1)] (x : ‚Ñù‚â•0) :
-- --   has_sum (Œª n, ‚à• ((coe : ‚Ñ§ ‚Üí ‚Ñù) ‚àò floor_seq x) n ‚à• * r ^ n) x.1:=
-- -- begin
-- --   by admit,--will be an easy consequence of the previous one
-- -- end

-- -- lemma has_sum_pow_floor_norm_nat (r' : ‚Ñù‚â•0)  [fact (r' < 1)] (h_nz :  r' ‚â† 0) (x : ‚Ñù‚â•0) :
-- --   has_sum (Œª n, ‚à• (floor_seq_nat x n : ‚Ñù) ‚à• * r' ^ n) x :=
-- --   -- has_sum (Œª n, ‚à• ((coe : ‚Ñï ‚Üí ‚Ñù) ‚àò floor_seq_nat x) n ‚à• * r' ^ n) x :=
-- -- begin
-- --   by admit,--will be an easy consequence of the previous one
-- -- end

-- -- noncomputable def Œ∏‚ÇÅ (r' : ‚Ñù‚â•0) [fact (r' < 1)] (r : ‚Ñù‚â•0) [fact (r < 1)] :
-- --  (laurent_measures r (Fintype.of punit)) ‚Üí ‚Ñù := Œª F, tsum (Œª n, (F.to_Rfct r n) * (r'.1) ^ n)
-- -- --FAE The assumption that r' < r is not needed by the definition of tsum
