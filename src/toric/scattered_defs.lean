import algebra.regular
import algebra.algebra.basic
import toric.pairing_dual_saturated

variables {R M : Type*} [add_comm_monoid M]

namespace submodule

section comm_semiring

variables [comm_semiring R] [semimodule R M]

/- TODO: develop the API for the definitions
`is_cyclic`, `pointed`, `has_extremal_ray`, `extremal_rays`.
Prove(?) `sup_extremal_rays`, if it is true, even in the test case. -/

/--  A cyclic submodule is a submodule generated by a single element. -/
def is_cyclic (s : submodule R M) : Prop := ∃ m : M, (R ∙ m) = s

variables (R M)

/--  A semimodule is cyclic if its top submodule is generated by a single element. -/
def semimodule.is_cyclic : Prop := is_cyclic (⊤ : submodule R M)

variables {R M}

/--  The zero submodule is cyclic. -/
lemma is_cyclic_bot : is_cyclic (⊥ : submodule R M) :=
⟨_, span_zero_singleton⟩

/--  An extremal ray of a submodule `s` is a cyclic submodule `r` with the property that if two
elements of `s` have sum contained in `r`, then the elements themselves are contained in `r`.
These are the "edges" of the cone. -/
structure has_extremal_ray (s r : submodule R M) : Prop :=
(incl : r ≤ s)
(is_cyclic : r.is_cyclic)
(mem_of_sum_mem : ∀ {x y : M}, x ∈ s → y ∈ s → x + y ∈ r → (x ∈ r ∧ y ∈ r))

/--  The set of all extremal rays of a submodule.  Hopefully, these are a good replacement for
generators, in the case in which the cone is `pointed`. -/
def extremal_rays (s : submodule R M) : set (submodule R M) :=
{ r | s.has_extremal_ray r }

end comm_semiring


section integral_domain

variables [integral_domain R] [semimodule R M]

/--  A sanity check that our definitions imply something not completely trivial
in an easy situation! -/
lemma sat {s t : submodule R M}
  (s0 : s ≠ ⊥) (ss : s.saturated) (st : s ≤ t) (ct : is_cyclic t) :
  s = t :=
begin
  refine le_antisymm st _,
  rcases ct with ⟨t0, rfl⟩,
  refine (span_singleton_le_iff_mem t0 s).mpr _,
  rcases (submodule.ne_bot_iff _).mp s0 with ⟨m, hm, m0⟩,
  rcases (le_span_singleton_iff.mp st) _ hm with ⟨c, rfl⟩,
  refine ss _ (is_regular_of_ne_zero _) _ hm,
  exact λ h, m0 (by rw [h, zero_smul]),
end

end integral_domain

end submodule
