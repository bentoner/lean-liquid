import analysis.special_functions.pow
import analysis.specific_limits
import analysis.normed_space.basic
import analysis.mean_inequalities
import category_theory.Fintype

import pseudo_normed_group.basic
import pseudo_normed_group.category

import for_mathlib.nnreal
import for_mathlib.real

universe u

noncomputable theory
open_locale big_operators nnreal classical

section definitions

@[nolint unused_arguments, derive add_comm_group]
def real_measures (p : ‚Ñù‚â•0) (S : Fintype) := S ‚Üí ‚Ñù

variables {p : ‚Ñù‚â•0} {S S' : Fintype.{u}}

notation `‚Ñ≥` := real_measures

namespace real_measures

@[simp] lemma zero_apply (s : S) : (0 : ‚Ñ≥ p S) s = 0 := rfl

@[simp] lemma add_apply (F G : ‚Ñ≥ p S) (s : S) : (F + G) s = F s + G s := rfl

@[simp] lemma neg_apply (F : ‚Ñ≥ p S) (s : S) : (-F) s = - (F s) := rfl

@[simp] lemma sub_apply (F G : ‚Ñ≥ p S) (s : S) : (F - G) s = F s - G s := rfl

instance : has_norm (‚Ñ≥ p S) := ‚ü®Œª F, ‚àë s, ‚à•F s‚à• ^ (p:‚Ñù)‚ü©

lemma norm_def (F : ‚Ñ≥ p S) : ‚à•F‚à• = ‚àë s, ‚à•F s‚à• ^ (p:‚Ñù) := rfl

instance : has_nnnorm (‚Ñ≥ p S) := ‚ü®Œª F, ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù)‚ü©

lemma nnnorm_def (F : ‚Ñ≥ p S) : ‚à•F‚à•‚Çä = ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù) := rfl

@[simp] protected lemma coe_nnnorm (F : ‚Ñ≥ p S) : (‚à•F‚à•‚Çä : ‚Ñù) = ‚à•F‚à• :=
by simp only [norm_def, nnnorm_def, nnreal.coe_sum, nnreal.coe_rpow, coe_nnnorm]

@[simp] protected lemma nnnorm_zero [hp : fact (0 < p)] : ‚à•(0 : ‚Ñ≥ p S)‚à•‚Çä = 0 :=
begin
  rw [nnnorm_def, finset.sum_eq_zero],
  rintro s -,
  rw [zero_apply, nnnorm_zero, nnreal.zero_rpow],
  exact_mod_cast hp.out.ne',
end

-- move this
lemma nnreal.rpow_add_le_add_rpow {p : ‚Ñù} (a b : ‚Ñù‚â•0) (hp_pos : 0 < p) (hp1 : p ‚â§ 1) :
  (a + b) ^ p ‚â§ a ^ p + b ^ p :=
begin
  rw [‚Üê ennreal.coe_le_coe],
  simpa only [‚Üê ennreal.coe_rpow_of_nonneg _ hp_pos.le, ennreal.coe_add]
    using ennreal.rpow_add_le_add_rpow a b hp_pos hp1,
end

-- move this
lemma nnreal.rpow_sum_le_sum_rpow
  {Œπ : Type*} (s : finset Œπ) {p : ‚Ñù} (a : Œπ ‚Üí ‚Ñù‚â•0) (hp_pos : 0 < p) (hp1 : p ‚â§ 1) :
  (‚àë i in s, a i) ^ p ‚â§ ‚àë i in s, (a i ^ p) :=
begin
  induction s using finset.induction_on with i s his IH,
  { simp only [nnreal.zero_rpow hp_pos.ne', finset.sum_empty, le_zero_iff], },
  { simp only [his, finset.sum_insert, not_false_iff],
    exact (nnreal.rpow_add_le_add_rpow _ _ hp_pos hp1).trans (add_le_add le_rfl IH), }
end

protected lemma nnnorm_add [h0p : fact (0 < p)] [hp1 : fact (p ‚â§ 1)]
  (F G : ‚Ñ≥ p S) : ‚à•F + G‚à•‚Çä ‚â§ ‚à•F‚à•‚Çä + ‚à•G‚à•‚Çä :=
begin
  dsimp [nnnorm_def],
  rw ‚Üê finset.sum_add_distrib,
  apply finset.sum_le_sum,
  intros s hs,
  have h0p' : (0 : ‚Ñù) < p, exact_mod_cast h0p.out,
  have hp1' : (p : ‚Ñù) ‚â§ 1, exact_mod_cast hp1.out,
  exact (nnreal.rpow_le_rpow (nnnorm_add_le _ _) h0p'.le).trans
    (@nnreal.rpow_add_le_add_rpow p (‚à•F s‚à•‚Çä) (‚à•G s‚à•‚Çä) h0p' hp1'),
end

--needed?
instance png_real_measures [fact (0 < p)] [fact (p ‚â§ 1)] : pseudo_normed_group (‚Ñ≥ p S) :=
{ filtration := Œª c, { F | ‚à•F‚à•‚Çä ‚â§ c },
  filtration_mono := Œª c‚ÇÅ c‚ÇÇ h F hF, by {dsimp at *, exact le_trans hF h},
  zero_mem_filtration := Œª c, by simp only [real_measures.nnnorm_zero, zero_le', set.mem_set_of_eq],
  neg_mem_filtration := Œª c F h, by { dsimp [nnnorm_def] at *, simp only [h, nnnorm_neg] },
  add_mem_filtration := Œª c‚ÇÅ c‚ÇÇ F‚ÇÅ F‚ÇÇ h‚ÇÅ h‚ÇÇ,
    (real_measures.nnnorm_add _ _).trans (add_le_add h‚ÇÅ h‚ÇÇ) }

lemma mem_filtration_iff [fact (0 < p)] [fact (p ‚â§ 1)] (F : ‚Ñ≥ p S) (c : ‚Ñù‚â•0) :
  F ‚àà pseudo_normed_group.filtration (‚Ñ≥ p S) c ‚Üî ‚à•F‚à•‚Çä ‚â§ c := iff.rfl

def map (f : S ‚ü∂ S') : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S' :=
Œª F s', ‚àë s in finset.univ.filter (Œª t, f t = s'), F s

@[simp]
lemma map_apply (f : S ‚ü∂ S') (F : ‚Ñ≥ p S) (s' : S') :
  map f F s' = ‚àë s in finset.univ.filter (Œª t, f t = s'), F s := rfl

@[simp]
lemma map_id : (map (ùüô S) : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S) = id :=
begin
  ext F s,
  rw [map_apply, finset.sum_filter, id.def],
  simp only [Fintype.id_apply, finset.sum_ite_eq', finset.mem_univ, if_true],
end

@[simp]
lemma map_comp {S'' : Fintype.{u}} (f : S ‚ü∂ S') (g : S' ‚ü∂ S'') :
  (map (f ‚â´ g) : ‚Ñ≥ p S ‚Üí ‚Ñ≥ p S'') = map g ‚àò map f :=
begin
  ext F s,
  simp only [function.comp_app, map_apply],
  convert finset.sum_bUnion _ using 1, swap 2, { classical, apply_instance },
  { apply finset.sum_congr,
    { change finset.univ.filter (Œª t, g (f t) = s) = _,
      ext i,
      simp only [true_and, exists_prop, finset.mem_univ, finset.mem_bUnion,
        exists_eq_right', finset.mem_filter] },
    { intros, refl } },
  { intros i hi j hj h k hk,
    refine h _,
    simp only [true_and, finset.inf_eq_inter, finset.mem_univ,
      finset.mem_filter, finset.mem_inter] at hk,
    rw [‚Üê hk.1, ‚Üê hk.2] }
end

lemma map_bound [h0p : fact (0 < p)] [hp1 : fact (p ‚â§ 1)] (f : S ‚ü∂ S') (F : ‚Ñ≥ p S) :
  ‚à•map f F‚à•‚Çä ‚â§ ‚à•F‚à•‚Çä :=
begin
  calc ‚àë s', ‚à•‚àë s in finset.univ.filter (Œª t, f t = s'), F s‚à•‚Çä ^ (p:‚Ñù)
      ‚â§ ‚àë s' : S', ‚àë s in finset.univ.filter (Œª t, f t = s'), ‚à•F s‚à•‚Çä ^ (p:‚Ñù) : _
  ... = ‚àë s, ‚à•F s‚à•‚Çä ^ (p:‚Ñù) : _,
  { apply finset.sum_le_sum,
    rintros s' -,
    have h0p' : (0 : ‚Ñù) < p, exact_mod_cast h0p.out,
    have hp1' : (p : ‚Ñù) ‚â§ 1, exact_mod_cast hp1.out,
    exact (nnreal.rpow_le_rpow (nnnorm_sum_le _ _) h0p'.le).trans
      (nnreal.rpow_sum_le_sum_rpow _ _ h0p' hp1'), },
  { rw ‚Üê finset.sum_bUnion,
    { refine finset.sum_congr _ _,
      { ext s,
        simp only [true_and, finset.mem_univ, finset.mem_bUnion, iff_true,
          exists_true_left, finset.mem_filter],
        refine ‚ü®_, finset.mem_univ _, rfl‚ü©, },
      { intros, refl } },
    { rintro x - y - h i hi,
      apply h,
      simp only [true_and, finset.inf_eq_inter, finset.mem_univ,
        finset.mem_filter, finset.mem_inter] at hi,
      rw [‚Üê hi.1, ‚Üê hi.2] } },
end

variables [fact (0 < p)] [fact (p ‚â§ 1)]

open pseudo_normed_group (filtration)

instance topological_space (c : ‚Ñù‚â•0) : topological_space (filtration (‚Ñ≥ p S) c) :=
@subtype.topological_space _ _ Pi.topological_space

instance t2_space (c : ‚Ñù‚â•0) : t2_space (filtration (‚Ñ≥ p S) c) :=
@subtype.t2_space _ _ Pi.topological_space _

lemma nnnorm_apply_le_of_nnnorm_le (F : ‚Ñ≥ p S) (s : S) (c : ‚Ñù‚â•0) (h : ‚à•F‚à•‚Çä ‚â§ c) :
  ‚à•F s‚à•‚Çä ‚â§ c ^ (p‚Åª¬π : ‚Ñù) :=
begin
  calc ‚à•F s‚à•‚Çä = (‚à•F s‚à•‚Çä ^ (p:‚Ñù)) ^ (p‚Åª¬π : ‚Ñù) : _
  ... ‚â§ c ^ (p‚Åª¬π : ‚Ñù) : _,
  { rw_mod_cast [‚Üê nnreal.rpow_mul, mul_inv_cancel, nnreal.rpow_one], exact ne_of_gt (fact.out _) },
  { apply nnreal.rpow_le_rpow _ (inv_pos.mpr _).le,
    { refine le_trans _ h,
      have aux := finset.sum_pi_single' s (‚à•F s‚à•‚Çä ^ (p:‚Ñù)) finset.univ,
      simp only [finset.mem_univ, if_true] at aux,
      rw ‚Üê aux,
      apply finset.sum_le_sum,
      rintro t -,
      split_ifs, { subst t }, { exact zero_le' } },
    { norm_cast, exact (fact.out _), } }
end

lemma apply_mem_Icc_of_nnnorm_le (F : ‚Ñ≥ p S) (s : S) (c : ‚Ñù‚â•0) (h : ‚à•F‚à•‚Çä ‚â§ c) :
  F s ‚àà set.Icc (-c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù) (c ^ (p‚Åª¬π : ‚Ñù) : ‚Ñù) :=
begin
  have := @set.mem_Icc_iff_abs_le ‚Ñù _ 0 (F s) (c ^ (p:‚Ñù)‚Åª¬π),
  simp only [zero_sub, abs_neg, zero_add, ‚Üê real.norm_eq_abs, ‚Üê coe_nnnorm, nnnorm_neg] at this,
  rw ‚Üê this,
  norm_cast,
  exact nnnorm_apply_le_of_nnnorm_le F s c h
end

-- move me
lemma continuous.sum {Œπ X A : Type*} [topological_space X]
  [topological_space A] [add_comm_monoid A] [has_continuous_add A]
  (s : finset Œπ) (f : Œπ ‚Üí X ‚Üí A) (hf : ‚àÄ i, continuous (f i)) :
  continuous (‚àë i in s, f i) :=
begin
  induction s using finset.induction_on with i s his IH,
  { simp only [finset.sum_empty], exact @continuous_zero X A _ _ _ },
  { simpa only [his, finset.sum_insert, not_false_iff] using (hf i).add IH }
end

-- move me
lemma continuous.sum' {Œπ X A : Type*} [topological_space X]
  [topological_space A] [add_comm_monoid A] [has_continuous_add A]
  (s : finset Œπ) (f : Œπ ‚Üí X ‚Üí A) (hf : ‚àÄ i, continuous (f i)) :
  continuous (Œª x, ‚àë i in s, f i x) :=
begin
  induction s using finset.induction_on with i s his IH,
  { simp only [finset.sum_empty], exact @continuous_zero X A _ _ _ },
  { simpa only [his, finset.sum_insert, not_false_iff] using (hf i).add IH }
end

instance compact_space (c : ‚Ñù‚â•0) : compact_space (filtration (‚Ñ≥ p S) c) :=
begin
  constructor,
  rw [‚Üê embedding_subtype_coe.to_inducing.is_compact_iff],
  simp only [set.image_univ, subtype.range_coe_subtype, set.set_of_mem_eq],
  let d : ‚Ñù := c ^ (p‚Åª¬π : ‚Ñù),
  let T : set (S ‚Üí ‚Ñù) := {x | ‚àÄ s, x s ‚àà set.Icc (-d) d},
  have hT : is_compact T := is_compact_pi_infinite (Œª s, is_compact_Icc),
  refine compact_of_is_closed_subset hT _ (Œª F hF s, apply_mem_Icc_of_nnnorm_le F s c hF),
  refine is_closed_le (continuous.sum' _ _ _) continuous_const,
  intro s,
  have h0p : 0 ‚â§ (p : ‚Ñù), { norm_cast, exact fact.out _ },
  exact (nnreal.continuous_rpow_const h0p).comp (continuous_nnnorm.comp (continuous_apply s)),
end

instance chpng_real_measures : comphaus_filtered_pseudo_normed_group (‚Ñ≥ p S) :=
{ continuous_add' := begin
    intros c‚ÇÅ c‚ÇÇ,
    apply continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.add'_eq],
    exact (continuous_subtype_val.comp continuous_fst).add
          (continuous_subtype_val.comp continuous_snd),
  end,
  continuous_neg' := begin
    intros c,
    apply continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.neg'_eq],
    exact continuous_subtype_val.neg,
  end,
  continuous_cast_le := begin
    introsI c‚ÇÅ c‚ÇÇ h,
    apply continuous_induced_rng,
    simp only [function.comp, pseudo_normed_group.coe_cast_le],
    exact continuous_subtype_val,
  end,
  ..(infer_instance : (pseudo_normed_group (‚Ñ≥ p S))) }

/-

variable {Œ± : Type*}

open pseudo_normed_group profinitely_filtered_pseudo_normed_group
  comphaus_filtered_pseudo_normed_group

def map_hom [fact (0 < p)] (f : S ‚ü∂ S') :
  comphaus_filtered_pseudo_normed_group_hom (‚Ñ≥ p S) (‚Ñ≥ p S') :=
{ to_fun := map f,
  map_zero' := begin
    ext F s i,
    simp,
  end,
  map_add' := begin
    intros F G,
    ext s i,
    simp [‚Üê finset.sum_bUnion, ‚Üê finset.sum_add_distrib],
  end,
  bound' := begin
    -- should we introduce strict morphisms, and the strict category, so we can have limits?
    use 1,
    rintros c F (hF : ‚à• F ‚à• ‚â§ c),
    exact le_trans (map_bound _ _) (by simpa),
  end,
  continuous' := begin
    intros c‚ÇÅ c‚ÇÇ f‚ÇÄ h,
    haveI h‚ÇÇ : fact (c‚ÇÇ ‚â§ c‚ÇÅ ‚äî c‚ÇÇ) := ‚ü®le_sup_right‚ü©,
    let e : filtration (‚Ñ≥ p S') c‚ÇÇ ‚Üí filtration (‚Ñ≥ p S') (c‚ÇÅ ‚äî c‚ÇÇ) :=
      cast_le,
    suffices : continuous (e ‚àò f‚ÇÄ),
    { rwa (embedding_cast_le _ _).to_inducing.continuous_iff },
    rw continuous_iff,
    intros T,
    let e' : real_measures_bdd p S T c‚ÇÅ ‚Üí real_measures_bdd p S T (c‚ÇÅ ‚äî c‚ÇÇ) :=
      Œª F, ‚ü®F, le_trans F.bound $ by exact_mod_cast le_sup_left‚ü©,
    have : truncate T ‚àò e ‚àò f‚ÇÄ = real_measures_bdd.map f ‚àò e' ‚àò truncate T,
    { ext F s' t,
      change (f‚ÇÄ F : ‚Ñ≥ p S') s' t = _,
      rw ‚Üê h,
      refl },
    rw this,
    continuity,
  end }

@[simps]
def functor (p : ‚Ñù‚â•0) [fact (0 < p)] : Fintype.{u} ‚•§ CompHausFiltPseuNormGrp.{u} :=
{ obj := Œª S, CompHausFiltPseuNormGrp.of $ ‚Ñ≥ p S,
  map := Œª S T f, map_hom f,
  map_id' := begin
    intros S,
    ext1,
    dsimp [map_hom],
    simp,
  end,
  map_comp' := begin
    intros S S' S'' f g,
    ext1,
    dsimp [map_hom],
    simp,
  end}

-/

end real_measures

end definitions
