import pseudo_normed_group.FP2
import condensed.adjunctions
import free_pfpng.acyclic
import for_mathlib.derived.ext_coproducts
import for_mathlib.derived.example
import breen_deligne.eval2
import system_of_complexes.shift_sub_id
import for_mathlib.AddCommGroup.explicit_products

noncomputable theory

open_locale nnreal

universe u

open category_theory category_theory.limits breen_deligne

section step1

variables (r' : ‚Ñù‚â•0)
variables (BD : breen_deligne.data) (Œ∫ : ‚Ñù‚â•0 ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0)
variables [‚àÄ c, BD.suitable (Œ∫ c)] [‚àÄ n, fact (monotone (function.swap Œ∫ n))]
variables (M : ProFiltPseuNormGrpWithTinv‚ÇÅ.{u} r')

abbreviation freeCond := Profinite_to_Condensed.{u} ‚ãô CondensedSet_to_Condensed_Ab

def QprimeFP_nat : ‚Ñù‚â•0 ‚•§ chain_complex (Condensed.{u} Ab.{u+1}) ‚Ñï :=
FPsystem r' BD ‚ü®M‚ü© Œ∫ ‚ãô (freeCond.{u}.map_FreeAb ‚ãô FreeAb.eval _).map_homological_complex _

def QprimeFP_int : ‚Ñù‚â•0 ‚•§ cochain_complex (Condensed.{u} Ab.{u+1}) ‚Ñ§ :=
QprimeFP_nat r' BD Œ∫ M ‚ãô homological_complex.embed complex_shape.embedding.nat_down_int_up

def QprimeFP : ‚Ñù‚â•0 ‚•§ bounded_homotopy_category (Condensed.{u} Ab.{u+1}) :=
QprimeFP_nat r' BD Œ∫ M ‚ãô chain_complex.to_bounded_homotopy_category

end step1

section step2

variables {r' : ‚Ñù‚â•0}
variables (BD : breen_deligne.package) (Œ∫ : ‚Ñù‚â•0 ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0)
variables [‚àÄ c, BD.data.suitable (Œ∫ c)] [‚àÄ n, fact (monotone (function.swap Œ∫ n))]
variables (M : ProFiltPseuNormGrpWithTinv‚ÇÅ.{u} r')

abbreviation freeCond' := Condensed_Ab_to_CondensedSet ‚ãô CondensedSet_to_Condensed_Ab

def ProFiltPseuNormGrpWithTinv‚ÇÅ.to_Condensed : Condensed.{u} Ab.{u+1} :=
(PFPNGT‚ÇÅ_to_CHFPNG‚ÇÅ‚Çë‚Çó r' ‚ãô CHFPNG‚ÇÅ_to_CHFPNG‚Çë‚Çó.{u} ‚ãô
  CompHausFiltPseuNormGrp.to_Condensed.{u}).obj M

-- move me
/-- `Tinv : M ‚Üí M` as hom of condensed abelian groups -/
def _root_.ProFiltPseuNormGrpWithTinv‚ÇÅ.Tinv_cond : M.to_Condensed ‚ü∂ M.to_Condensed :=
(CompHausFiltPseuNormGrp.to_Condensed.{u}).map
  profinitely_filtered_pseudo_normed_group_with_Tinv.Tinv

local attribute [instance] type_pow

set_option pp.universes true

def QprimeFP_incl_aux'' (c : ‚Ñù‚â•0) (n : ‚Ñï) (M : ProFiltPseuNormGrpWithTinv.{u} r') (i : fin n) :
  (FiltrationPow r' c n).obj M ‚ü∂ ((Filtration r').obj c).obj M :=
((Filtration r').obj c).map $
  profinitely_filtered_pseudo_normed_group_with_Tinv.pi_proj _ _ i

def QprimeFP_incl_aux'
  (c : ‚Ñù‚â•0) (n : ‚Ñï) (i : (fin n)) (S : Profinite.{u}·µí·µñ) :
  ulift_functor.{u+1 u}.obj (opposite.unop.{u+2} S ‚ü∂ pseudo_normed_group.filtration_obj.{u} (M ^ n) c) ‚ü∂
  ulift_functor.{u+1 u}.obj ((CompHausFiltPseuNormGrp.of.{u} ‚Ü•((PFPNGT‚ÇÅ_to_PFPNG‚ÇÅ‚Çë‚Çó.{u} r').obj M)).presheaf (opposite.unop.{u+2} S)) :=
ulift_functor.map $ Œª f, ‚ü®subtype.val ‚àò QprimeFP_incl_aux'' c n ‚ü®M‚ü© i ‚àò f,
  by refine ‚ü®_, _, continuous.comp _ _, rfl‚ü©; apply continuous_map.continuous‚ü©

-- move me
instance : preserves_limits (Condensed_Ab_to_CondensedSet.{u}) :=
adjunction.right_adjoint_preserves_limits Condensed_Ab_CondensedSet_adjunction

-- move me
instance : preserves_limits CondensedSet_to_presheaf :=
adjunction.right_adjoint_preserves_limits CondensedSet_presheaf_adjunction

universe v

lemma _root_.Ab.ulift_map_apply {A B : Ab.{u}} (f : A ‚ü∂ B) :
  ‚áë(Ab.ulift.{v}.map f) = ulift_functor.map f :=
by { ext, refl }

def QprimeFP_incl_aux (c : ‚Ñù‚â•0) (n : ‚Ñï) :
  (pseudo_normed_group.filtration_obj (M ^ n) c).to_Condensed ‚ü∂
  (Condensed_Ab_to_CondensedSet.obj (‚®Å Œª (i : ulift (fin n)), M.to_Condensed)) :=
begin
  let x := biproduct.is_limit (Œª (i : ulift (fin n)), M.to_Condensed),
  let y := is_limit_of_preserves (Condensed_Ab_to_CondensedSet ‚ãô CondensedSet_to_presheaf) x,
  refine ‚ü®y.lift ‚ü®_, ‚ü®Œª i, ‚ü®_, _‚ü©, _‚ü©‚ü©‚ü©,
  { refine QprimeFP_incl_aux' _ _ _ i.down, },
  { intros S T f,
    dsimp [QprimeFP_incl_aux', ProFiltPseuNormGrpWithTinv‚ÇÅ.to_Condensed],
    rw [‚Üê ulift_functor.map_comp, Ab.ulift_map_apply, ‚Üê ulift_functor.map_comp],
    congr' 1, },
  { clear y x,
    rintros ‚ü®i‚ü© ‚ü®j‚ü© ‚ü®‚ü®‚ü®‚ü©‚ü©‚ü©,
    ext S : 2,
    dsimp [QprimeFP_incl_aux', ProFiltPseuNormGrpWithTinv‚ÇÅ.to_Condensed],
    simp only [discrete.functor_map_id, category.id_comp],
    symmetry, apply category.comp_id, }
end
.

set_option pp.universes false

lemma _root_.free_abelian_group.lift_map {A B C : Type*} [add_comm_group C]
  (f : A ‚Üí B) (g : B ‚Üí C) (x) :
  free_abelian_group.lift g (free_abelian_group.map f x) =
  free_abelian_group.lift (g ‚àò f) x :=
begin
  rw [‚Üê add_monoid_hom.comp_apply], congr' 1, clear x, ext x,
  simp only [add_monoid_hom.coe_comp, function.comp_app, free_abelian_group.map_of_apply, free_abelian_group.lift.of, id.def]
end

lemma _root_.free_abelian_group.lift_id_map {A B : Type*} [add_comm_group B]
  (f : A ‚Üí B) (x) :
  free_abelian_group.lift id (free_abelian_group.map f x) =
  free_abelian_group.lift f x :=
free_abelian_group.lift_map _ _ _

open_locale big_operators

lemma _root_.free_abelian_group.coeff_of_not_mem_support
  {X : Type*} (a : free_abelian_group X) (x : X) (h : x ‚àâ a.support) :
  free_abelian_group.coeff x a = 0 :=
begin
  dsimp [free_abelian_group.coeff],
  rwa [‚Üê finsupp.not_mem_support_iff],
end

lemma _root_.free_abelian_group.lift_eq_sum {A B : Type*} [add_comm_group B]
  (f : A ‚Üí B) (x) :
  free_abelian_group.lift f x = ‚àë a in x.support, free_abelian_group.coeff a x ‚Ä¢ f a :=
begin
  apply free_abelian_group.induction_on'' x; clear x,
  { simp only [map_zero, zero_smul, finset.sum_const_zero], },
  { intros n hn a,
    simp only [map_zsmul, smul_assoc, ‚Üê finset.smul_sum,
      free_abelian_group.lift.of,
      free_abelian_group.support_zsmul n hn,
      free_abelian_group.support_of, finset.sum_singleton,
      free_abelian_group.coeff_of_self, one_smul], },
  { intros x n hn a hax IH1 IH2, specialize IH2 n,
    simp only [map_add, map_zsmul, smul_assoc, free_abelian_group.lift.of,
      free_abelian_group.support_add_smul_of x n hn a hax,
      free_abelian_group.support_zsmul n hn,
      free_abelian_group.support_of, finset.sum_singleton] at IH2 ‚ä¢,
    rw [finset.sum_insert], swap, exact hax,
    simp only [IH1, free_abelian_group.coeff_of_self, smul_assoc, one_smul, add_smul,
      finset.sum_add_distrib, free_abelian_group.coeff_of_not_mem_support _ _ hax,
      zero_smul, zero_add],
    rw add_comm, refine congr_arg2 _ rfl _, symmetry, convert add_zero _,
    rw finset.sum_eq_zero,
    intros z hz,
    rw [free_abelian_group.coeff_of_not_mem_support, zero_smul, smul_zero],
    rw [free_abelian_group.support_of, finset.mem_singleton], rintro rfl, exact hax hz }
end

lemma lift_app {C ùìê Œπ : Type*} [category C] [category ùìê] [preadditive ùìê]
  {F G : C ‚•§ ùìê} (f : Œπ ‚Üí (F ‚ü∂ G)) (x) (T) :
  (free_abelian_group.lift f x).app T = free_abelian_group.lift (Œª i, (f i).app T) x :=
begin
  simp only [‚Üê nat_trans.app_hom_apply, ‚Üê add_monoid_hom.comp_apply],
  congr' 1, clear x, ext x,
  simp only [add_monoid_hom.coe_comp, function.comp_app, free_abelian_group.lift.of],
end

lemma map_FreeAb_comp_map {X Y Z : Type*} [category X] [category Y] [category Z]
  (F : X ‚•§ Y) (G : Y ‚•§ Z) {Œ± Œ≤ : FreeAb X} (f : Œ± ‚ü∂ Œ≤) :
  (F ‚ãô G).map_FreeAb.map f = G.map_FreeAb.map (F.map_FreeAb.map f) :=
begin
  dsimp only [functor.map_FreeAb, functor.comp_map],
  rw [‚Üê add_monoid_hom.comp_apply], congr' 1, clear f,
  ext f,
  simp only [free_abelian_group.map_of_apply, functor.comp_map, add_monoid_hom.coe_comp, function.comp_app],
end

def QprimeFP_incl (c : ‚Ñù‚â•0) :
  (QprimeFP_int r' BD.data Œ∫ M).obj c ‚ü∂
  (BD.eval' freeCond').obj M.to_Condensed :=
(homological_complex.embed complex_shape.embedding.nat_down_int_up).map
{ f := Œª n, CondensedSet_to_Condensed_Ab.map $ QprimeFP_incl_aux _ _ _,
  comm' := begin
    rintro i j (rfl : _ = _),
    dsimp only [data.eval_functor, functor.comp_obj, functor.flip_obj_obj,
      homological_complex.functor_eval_obj, homological_complex.functor_eval.obj_obj_d,
      data.eval_functor'_obj_d, universal_map.eval_Pow],
    dsimp only [QprimeFP_nat, FPsystem, functor.comp_obj, functor.map_homological_complex_obj_d],
    rw [chain_complex.of_d],
    delta freeCond freeCond',
    rw [functor.comp_map, map_FreeAb_comp_map, lift_app],
    dsimp only [FreeAb.eval, functor.map_FreeAb, FPsystem.d,
      universal_map.eval_FP2],
    simp only [whisker_right_app, free_abelian_group.lift_map, function.comp.left_id,
      nat_trans.app_sum, map_sum, basic_universal_map.eval_Pow_app,
      nat_trans.app_zsmul, basic_universal_map.eval_FP2],
    rw [free_abelian_group.lift_eq_sum],
    sorry
  end }

variables (Œπ : ulift.{u+1} ‚Ñï ‚Üí ‚Ñù‚â•0) (hŒπ : monotone Œπ)

def QprimeFP_sigma_proj :
  ‚àê (Œª k, (QprimeFP_int r' BD.data Œ∫ M).obj (Œπ k)) ‚ü∂
  (BD.eval' freeCond').obj M.to_Condensed :=
sigma.desc $ Œª n, QprimeFP_incl BD Œ∫ M _

instance QprimeFP.uniformly_bounded :
  bounded_homotopy_category.uniformly_bounded (Œª k, (QprimeFP r' BD.data Œ∫ M).obj (Œπ k)) :=
begin
  use 1, intro k, apply chain_complex.bounded_by_one,
end

end step2

section step3
open bounded_homotopy_category

variables (Œπ : ulift.{u+1} ‚Ñï ‚Üí ‚Ñù‚â•0) (hŒπ : monotone Œπ)
variables {C : Type*} [category C] [preadditive C]
variables (A B : ‚Ñù‚â•0 ‚•§ C)
variables [has_coproduct (Œª (k : ulift ‚Ñï), A.obj (Œπ k))]
variables [has_coproduct (Œª (k : ulift ‚Ñï), B.obj (Œπ k))]
-- variables [uniformly_bounded (Œª k, A.obj (Œπ k))]

def sigma_shift_cone (c : cofan (Œª k, A.obj (Œπ k))) :
  cofan (Œª k, A.obj (Œπ k)) :=
{ X := c.X,
  Œπ := discrete.nat_trans $ Œª (j:ulift ‚Ñï),
    A.map (hom_of_le $ hŒπ $ (by { cases j, apply nat.le_succ } : j ‚â§ ‚ü®j.down+1‚ü©)) ‚â´ c.Œπ.app _ }

def sigma_shift' (c : cofan (Œª k, A.obj (Œπ k))) (hc : is_colimit c) :
  c.X ‚ü∂ (sigma_shift_cone Œπ hŒπ A c).X := hc.desc _

def sigma_shift : ‚àê (Œª k, A.obj (Œπ k)) ‚ü∂ ‚àê (Œª k, A.obj (Œπ k)) :=
sigma_shift' _ hŒπ _ _ (colimit.is_colimit _)

def QprimeFP.shift_sub_id : ‚àê (Œª k, A.obj (Œπ k)) ‚ü∂ ‚àê (Œª k, A.obj (Œπ k)) :=
sigma_shift _ hŒπ _ - ùüô _

variables {A B}

def sigma_map (f : A ‚ü∂ B) : ‚àê (Œª k, A.obj (Œπ k)) ‚ü∂ ‚àê (Œª k, B.obj (Œπ k)) :=
sigma.desc $ Œª k, f.app _ ‚â´ sigma.Œπ _ k

end step3

section step4

variables {r' : ‚Ñù‚â•0}
variables (BD : breen_deligne.package) (Œ∫ : ‚Ñù‚â•0 ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0)
variables [‚àÄ c, BD.data.suitable (Œ∫ c)] [‚àÄ n, fact (monotone (function.swap Œ∫ n))]
variables (M : ProFiltPseuNormGrpWithTinv‚ÇÅ.{u} r')
variables (Œπ : ulift.{u+1} ‚Ñï ‚Üí ‚Ñù‚â•0) (hŒπ : monotone Œπ)

open opposite category_theory.preadditive

lemma mono_iff_ExtrDisc {A B : Condensed.{u} Ab.{u+1}} (f : A ‚ü∂ B) :
  mono f ‚Üî ‚àÄ S : ExtrDisc, mono (f.1.app $ ExtrDisc_to_Profinite.op.obj (op S)) :=
begin
  split,
  { intros H S,
    erw (abelian.tfae_mono (A.val.obj (op S.val)) (f.val.app (op S.val))).out 0 2,
    erw (abelian.tfae_mono A f).out 0 2 at H,
    rw Condensed.exact_iff_ExtrDisc at H,
    apply H, },
  { intro H,
    apply exact.mono_of_exact_zero_left, swap, exact A,
    rw Condensed.exact_iff_ExtrDisc,
    intro S, specialize H S,
    show exact 0 _,
    erw (abelian.tfae_mono (A.val.obj (op S.val)) (f.val.app (op S.val))).out 2 0,
    exact H, }
end

lemma short_exact_iff_ExtrDisc {A B C : Condensed.{u} Ab.{u+1}} (f : A ‚ü∂ B) (g : B ‚ü∂ C) :
  short_exact f g ‚Üî ‚àÄ S : ExtrDisc, short_exact
      (f.1.app $ ExtrDisc_to_Profinite.op.obj (op S))
      (g.1.app $ ExtrDisc_to_Profinite.op.obj (op S)) :=
begin
  split,
  { intros H S,
    apply_with short_exact.mk {instances:=ff},
    { revert S, rw ‚Üê mono_iff_ExtrDisc, exact H.mono, },
    { rw AddCommGroup.epi_iff_surjective,
      revert S, erw ‚Üê is_epi_iff_forall_surjective, exact H.epi, },
    { revert S, rw ‚Üê Condensed.exact_iff_ExtrDisc, exact H.exact } },
  { intro H,
    apply_with short_exact.mk {instances:=ff},
    { rw mono_iff_ExtrDisc, intro S, exact (H S).mono, },
    { simp only [is_epi_iff_forall_surjective, ‚Üê AddCommGroup.epi_iff_surjective],
      intro S, exact (H S).epi, },
    { rw Condensed.exact_iff_ExtrDisc, intro S, exact (H S).exact } }
end
.

open_locale classical

set_option pp.universes true

.

def coproduct_eval_iso
  {Œ± : Type (u+1)} (X : Œ± ‚Üí homological_complex (Condensed.{u} Ab.{u+1}) (complex_shape.up ‚Ñ§))
  (n : ‚Ñ§) (T : ExtrDisc.{u}) :
  ((‚àê X).X n).val.obj (op T.val) ‚âÖ
  AddCommGroup.of (direct_sum Œ± (Œª a, ((X a).X n).val.obj (op T.val))) :=
begin
  refine preserves_colimit_iso
    ((homological_complex.eval (Condensed.{u} Ab.{u+1}) (complex_shape.up ‚Ñ§) n
    ‚ãô Condensed.evaluation Ab.{u+1} T.val)) _ ‚â™‚â´ _,
  refine _ ‚â™‚â´ (colimit.is_colimit $ discrete.functor
    (Œª a, ((X a).X n).val.obj (op T.val))).cocone_point_unique_up_to_iso
    (AddCommGroup.is_colimit_direct_sum_cofan.{u+1 u+1} (Œª a, ((X a).X n).val.obj (op T.val))),
  refine has_colimit.iso_of_nat_iso (discrete.nat_iso _),
  intros i, exact iso.refl _,
end

lemma sigma_Œπ_coproduct_eval_iso
  {Œ± : Type (u+1)} (X : Œ± ‚Üí homological_complex (Condensed.{u} Ab.{u+1}) (complex_shape.up ‚Ñ§))
  (n : ‚Ñ§) (T : ExtrDisc.{u}) (a : Œ±) :
  ((sigma.Œπ X a : X a ‚ü∂ _).f n).val.app (op T.val) ‚â´
  (coproduct_eval_iso _ _ _).hom =
  direct_sum.of ((Œª a, ((X a).X n).val.obj (op T.val))) a :=
begin
  dsimp only [coproduct_eval_iso],
  erw (is_colimit_of_preserves (homological_complex.eval.{u+1 u+2 0}
    (Condensed.{u u+1 u+2} Ab.{u+1}) (complex_shape.up.{0} ‚Ñ§) n ‚ãô
    Condensed.evaluation.{u+2 u+1 u} Ab.{u+1} T.val) _).fac_assoc,
  dsimp,
  erw colimit.Œπ_desc_assoc,
  dsimp, simpa only [category.id_comp, colimit.comp_cocone_point_unique_up_to_iso_hom],
end

lemma QprimeFP.mono (n : ‚Ñ§) :
  mono ((QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD.data Œ∫ M)).f n) :=
begin
  rw mono_iff_ExtrDisc, intros T,
  let e : ((‚àê Œª (k : ulift.{u+1 0} ‚Ñï), (QprimeFP_int.{u} r' BD.data Œ∫ M).obj (Œπ k)).X n).val.obj
    (op T.val) ‚âÖ _ := coproduct_eval_iso _ _ _,
  let Q := QprimeFP_int r' BD.data Œ∫ M,
  let œÜ : ulift.{u+1} ‚Ñï ‚Üí Ab.{u+1} := Œª k, ((Q.obj (Œπ k)).X n).val.obj (op T.val),
  let D := AddCommGroup.direct_sum_cofan.{u+1 u+1} œÜ,
  let hD := AddCommGroup.is_colimit_direct_sum_cofan.{u+1 u+1} œÜ,
  let g : D.X ‚ü∂ D.X := sigma_shift'.{u u+2 u+1} _ hŒπ (Q ‚ãô (homological_complex.eval
    (Condensed.{u} Ab.{u+1}) (complex_shape.up ‚Ñ§) n) ‚ãô Condensed.evaluation _ T.val) D hD,
  let f := _, change mono f,
  have hf : f = e.hom ‚â´ (g - ùüô _) ‚â´ e.inv,
  { rw [‚Üê category.assoc, iso.eq_comp_inv],
    dsimp [f, QprimeFP.shift_sub_id],
    change (_ - _) ‚â´ _ = _,
    simp only [comp_sub, sub_comp, category.id_comp, category.comp_id, Sheaf.hom.id_val,
      nat_trans.id_app], congr' 1,
    refine ((is_colimit_of_preserves (homological_complex.eval.{u+1 u+2 0}
      (Condensed.{u u+1 u+2} Ab.{u+1}) (complex_shape.up.{0} ‚Ñ§) n ‚ãô
      Condensed.evaluation.{u+2 u+1 u} Ab.{u+1} T.val) (colimit.is_colimit _))).hom_ext (Œª j, _),
    dsimp [sigma_shift],
    slice_lhs 1 2
    { erw [‚Üê nat_trans.comp_app, ‚Üê Sheaf.hom.comp_val, ‚Üê homological_complex.comp_f,
        colimit.Œπ_desc] },
    slice_rhs 1 2
    { erw sigma_Œπ_coproduct_eval_iso },
    dsimp [sigma_shift_cone],
    rw category.assoc,
    slice_lhs 2 3
    { erw sigma_Œπ_coproduct_eval_iso },
    erw hD.fac, refl },
  suffices : mono (g - ùüô _),
  { rw hf,
    apply_with mono_comp { instances := ff },
    apply_instance,
    apply_with mono_comp { instances := ff },
    exact this,
    apply_instance },
  rw [AddCommGroup.mono_iff_injective, injective_iff_map_eq_zero],
  intros x hx,
  erw [sub_eq_zero, id_apply] at hx,
  ext ‚ü®i‚ü©,
  classical,
  induction i with i IH,
  { rw ‚Üê hx,
    dsimp [g, sigma_shift', sigma_shift_cone, hD, AddCommGroup.is_colimit_direct_sum_cofan,
      AddCommGroup.direct_sum_desc, discrete.nat_trans, direct_sum.to_add_monoid],
    rw [dfinsupp.sum_add_hom_apply, dfinsupp.sum_apply],
    apply finset.sum_eq_zero,
    rintro ‚ü®j‚ü© -,
    convert dif_neg _,
    rw [finset.mem_singleton],
    intro H, rw ulift.ext_iff at H, revert H, apply nat.no_confusion, },
  { rw ‚Üê hx,
    classical,
    dsimp [g, sigma_shift', sigma_shift_cone, hD, AddCommGroup.is_colimit_direct_sum_cofan,
      AddCommGroup.direct_sum_desc, discrete.nat_trans, direct_sum.to_add_monoid],
    rw [dfinsupp.sum_add_hom_apply, dfinsupp.sum_apply],
    rw dfinsupp.zero_apply at IH,
    convert finset.sum_eq_single (ulift.up $ i) _ _,
    { rw [IH, add_monoid_hom.map_zero, dfinsupp.zero_apply], },
    { rintro ‚ü®j‚ü© - hj, convert dif_neg _, rw [finset.mem_singleton],
      intro H, apply hj, rw ulift.ext_iff at H ‚ä¢, change i+1 = j+1 at H,
      change j = i, linarith only [H] },
    { intro, rw [IH, add_monoid_hom.map_zero, dfinsupp.zero_apply], }, },
  recover, all_goals { classical; apply_instance }
end
.

lemma QprimeFP.short_exact (n : ‚Ñ§) :
  short_exact
    ((QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD.data Œ∫ M)).f n)
    ((QprimeFP_sigma_proj BD Œ∫ M Œπ).f n) :=
begin
  apply_with short_exact.mk {instances:=ff},
  { apply QprimeFP.mono },
  { rw is_epi_iff_forall_surjective,
    intro S,
    sorry },
  { rw Condensed.exact_iff_ExtrDisc,
    intro S,
    sorry },
  recover, all_goals { classical; apply_instance }
end

end step4

section step5

variables {r' : ‚Ñù‚â•0} [fact (0 < r')] [fact (r' ‚â§ 1)]
variables (BD : breen_deligne.data)
variables (Œ∫ Œ∫‚ÇÇ : ‚Ñù‚â•0 ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0)
variables [‚àÄ (c : ‚Ñù‚â•0), BD.suitable (Œ∫ c)] [‚àÄ n, fact (monotone (function.swap Œ∫ n))]
variables [‚àÄ (c : ‚Ñù‚â•0), BD.suitable (Œ∫‚ÇÇ c)] [‚àÄ n, fact (monotone (function.swap Œ∫‚ÇÇ n))]
variables (M : ProFiltPseuNormGrpWithTinv‚ÇÅ.{u} r')
variables (Œπ : ulift.{u+1} ‚Ñï ‚Üí ‚Ñù‚â•0) (hŒπ : monotone Œπ)

def QprimeFP_nat.Tinv [‚àÄ c n, fact (Œ∫ c n ‚â§ r' * Œ∫‚ÇÇ c n)] :
  (QprimeFP_nat r' BD Œ∫ M) ‚ü∂ (QprimeFP_nat r' BD Œ∫‚ÇÇ M) :=
whisker_right (FPsystem.Tinv.{u} r' BD ‚ü®M‚ü© _ _) _

def QprimeFP_int.Tinv [‚àÄ c n, fact (Œ∫ c n ‚â§ r' * Œ∫‚ÇÇ c n)] :
  (QprimeFP_int r' BD Œ∫ M) ‚ü∂ (QprimeFP_int r' BD Œ∫‚ÇÇ M) :=
whisker_right (QprimeFP_nat.Tinv _ _ _ _)
  (homological_complex.embed complex_shape.embedding.nat_down_int_up)

def QprimeFP.Tinv [‚àÄ c n, fact (Œ∫ c n ‚â§ r' * Œ∫‚ÇÇ c n)] :
  (QprimeFP r' BD Œ∫ M) ‚ü∂ (QprimeFP r' BD Œ∫‚ÇÇ M) :=
whisker_right (QprimeFP_nat.Tinv _ _ _ _) chain_complex.to_bounded_homotopy_category

/-- The natural inclusion map -/
def QprimeFP_nat.Œπ [‚àÄ c n, fact (Œ∫ c n ‚â§ Œ∫‚ÇÇ c n)] :
  (QprimeFP_nat r' BD Œ∫ M) ‚ü∂ (QprimeFP_nat r' BD Œ∫‚ÇÇ M) :=
whisker_right (FPsystem.res r' BD ‚ü®M‚ü© _ _) _

/-- The natural inclusion map -/
def QprimeFP_int.Œπ [‚àÄ c n, fact (Œ∫ c n ‚â§ Œ∫‚ÇÇ c n)] :
  (QprimeFP_int r' BD Œ∫ M) ‚ü∂ (QprimeFP_int r' BD Œ∫‚ÇÇ M) :=
whisker_right (QprimeFP_nat.Œπ _ _ _ _)
  (homological_complex.embed complex_shape.embedding.nat_down_int_up)

/-- The natural inclusion map -/
def QprimeFP.Œπ [‚àÄ c n, fact (Œ∫ c n ‚â§ Œ∫‚ÇÇ c n)] :
  (QprimeFP r' BD Œ∫ M) ‚ü∂ (QprimeFP r' BD Œ∫‚ÇÇ M) :=
whisker_right (QprimeFP_nat.Œπ _ _ _ _) chain_complex.to_bounded_homotopy_category

open category_theory.preadditive

lemma commsq_shift_sub_id_Tinv [‚àÄ (c : ‚Ñù‚â•0) (n : ‚Ñï), fact (Œ∫‚ÇÇ c n ‚â§ r' * Œ∫ c n)] :
  commsq (QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD Œ∫‚ÇÇ M))
  (sigma_map (Œª (k : ulift ‚Ñï), Œπ k) (QprimeFP_int.Tinv BD Œ∫‚ÇÇ Œ∫ M))
  (sigma_map (Œª (k : ulift ‚Ñï), Œπ k) (QprimeFP_int.Tinv BD Œ∫‚ÇÇ Œ∫ M))
  (QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD Œ∫ M)) :=
commsq.of_eq begin
  delta QprimeFP.shift_sub_id,
  rw [sub_comp, comp_sub, category.id_comp, category.comp_id],
  refine congr_arg2 _ _ rfl,
  apply colimit.hom_ext, intro j,
  dsimp [sigma_shift, sigma_shift', sigma_shift_cone],
  simp only [sigma_shift, sigma_shift', sigma_shift_cone, sigma_map, colimit.Œπ_desc_assoc,
    colimit.Œπ_desc, cofan.mk_Œπ_app, category.assoc, nat_trans.naturality_assoc,
    discrete.nat_trans_app],
end

lemma commsq_shift_sub_id_Œπ [‚àÄ (c : ‚Ñù‚â•0) (n : ‚Ñï), fact (Œ∫‚ÇÇ c n ‚â§ Œ∫ c n)] :
  commsq (QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD Œ∫‚ÇÇ M))
  (sigma_map (Œª (k : ulift ‚Ñï), Œπ k) (QprimeFP_int.Œπ BD Œ∫‚ÇÇ Œ∫ M))
  (sigma_map (Œª (k : ulift ‚Ñï), Œπ k) (QprimeFP_int.Œπ BD Œ∫‚ÇÇ Œ∫ M))
  (QprimeFP.shift_sub_id Œπ hŒπ (QprimeFP_int r' BD Œ∫ M)) :=
commsq.of_eq begin
  delta QprimeFP.shift_sub_id,
  rw [sub_comp, comp_sub, category.id_comp, category.comp_id],
  refine congr_arg2 _ _ rfl,
  apply colimit.hom_ext, intro j,
  dsimp [sigma_shift, sigma_shift', sigma_shift_cone],
  simp only [sigma_shift, sigma_shift', sigma_shift_cone, sigma_map, colimit.Œπ_desc_assoc,
    colimit.Œπ_desc, cofan.mk_Œπ_app, category.assoc, nat_trans.naturality_assoc,
    discrete.nat_trans_app],
end

end step5

section step6

variables {r' : ‚Ñù‚â•0} [fact (0 < r')] [fact (r' ‚â§ 1)]
variables (BD : breen_deligne.package)
variables (Œ∫ Œ∫‚ÇÇ : ‚Ñù‚â•0 ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0)
variables [‚àÄ (c : ‚Ñù‚â•0), BD.data.suitable (Œ∫ c)] [‚àÄ n, fact (monotone (function.swap Œ∫ n))]
variables [‚àÄ (c : ‚Ñù‚â•0), BD.data.suitable (Œ∫‚ÇÇ c)] [‚àÄ n, fact (monotone (function.swap Œ∫‚ÇÇ n))]
variables (M : ProFiltPseuNormGrpWithTinv‚ÇÅ.{u} r')
variables (Œπ : ulift.{u+1} ‚Ñï ‚Üí ‚Ñù‚â•0) (hŒπ : monotone Œπ)

open category_theory.preadditive

lemma commsq_sigma_proj_Tinv [‚àÄ (c : ‚Ñù‚â•0) (n : ‚Ñï), fact (Œ∫‚ÇÇ c n ‚â§ r' * Œ∫ c n)] :
  commsq (QprimeFP_sigma_proj BD Œ∫‚ÇÇ M Œπ) (sigma_map (Œª (k : ulift ‚Ñï), Œπ k)
    (QprimeFP_int.Tinv BD.data Œ∫‚ÇÇ Œ∫ M))
  ((BD.eval' freeCond').map M.Tinv_cond)
  (QprimeFP_sigma_proj BD Œ∫ M Œπ) :=
commsq.of_eq begin
  apply colimit.hom_ext, intro j,
  simp only [QprimeFP_sigma_proj, sigma_map, colimit.Œπ_desc_assoc, colimit.Œπ_desc,
    cofan.mk_Œπ_app, category.assoc, nat_trans.naturality_assoc],
  dsimp only [QprimeFP_incl, QprimeFP_int.Tinv, whisker_right_app,
    package.eval', functor.comp_map],
  rw [‚Üê functor.map_comp, ‚Üê functor.map_comp],
  refine congr_arg _ _,
  ext n : 2,
  dsimp only [homological_complex.comp_f, data.eval_functor, functor.comp_obj, functor.flip_obj_map,
    homological_complex.functor_eval_map_app_f, data.eval_functor'_obj_X_map, functor.comp_map,
    QprimeFP_nat.Tinv, whisker_right_app, functor.map_homological_complex_map_f],
  rw [map_FreeAb_comp_map],
  sorry
end

lemma commsq_sigma_proj_Œπ [‚àÄ (c : ‚Ñù‚â•0) (n : ‚Ñï), fact (Œ∫‚ÇÇ c n ‚â§ Œ∫ c n)] :
  commsq (QprimeFP_sigma_proj BD Œ∫‚ÇÇ M Œπ) (sigma_map (Œª (k : ulift ‚Ñï), Œπ k)
    (QprimeFP_int.Œπ BD.data Œ∫‚ÇÇ Œ∫ M)) (ùüô _) (QprimeFP_sigma_proj BD Œ∫ M Œπ) :=
commsq.of_eq begin
  simp only [category.comp_id],
  apply colimit.hom_ext, intro j,
  simp only [QprimeFP_sigma_proj, sigma_map, colimit.Œπ_desc_assoc, colimit.Œπ_desc,
    cofan.mk_Œπ_app, category.assoc, nat_trans.naturality_assoc],
  sorry
end

end step6

-- variables (f : ‚Ñï ‚Üí ‚Ñù‚â•0)
-- #check ‚àê (Œª i, (QprimeFP r' BD Œ∫ M).obj (f i))
