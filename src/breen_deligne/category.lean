import breen_deligne.universal_map
import breen_deligne.functorial_map
import system_of_complexes.complex

import for_mathlib.free_abelian_group

/-!

# The category of Breen-Deligne data

This file defines the category whose objects are the natural numbers
and whose morphisms `m ‚ü∂ n` are functorial maps `œÜ_A : ‚Ñ§[A^m] ‚Üí ‚Ñ§[A^n]`.

-/

namespace breen_deligne

open free_abelian_group category_theory

/-- The category whose objects are natural numbers
and whose morphisms are the free abelian groups generated by
matrices with integer coefficients. -/
@[derive comm_semiring] def FreeMat := ‚Ñï

namespace FreeMat

instance : small_category FreeMat :=
{ hom := Œª m n, universal_map m n,
  id := universal_map.id,
  comp := Œª l m n f g, universal_map.comp g f,
  id_comp' := Œª n f, universal_map.comp_id,
  comp_id' := Œª n f, universal_map.id_comp,
  assoc' := Œª k l m n f g h, (universal_map.comp_assoc h g f).symm }

instance : preadditive FreeMat :=
{ hom_group := Œª m n, infer_instance,
  add_comp' := Œª l m n f g h, add_monoid_hom.map_add _ _ _,
  comp_add' := Œª l m n f g h, show universal_map.comp (g + h) f = _,
    by { rw [add_monoid_hom.map_add, add_monoid_hom.add_apply], refl } }

open universal_map

lemma double_comp_double {l m n : FreeMat} (f : l ‚ü∂ m) (g : m ‚ü∂ n) :
  (f.double ‚â´ g.double : l+l ‚ü∂ n+n) = (f ‚â´ g).double :=
comp_double_double _ _

lemma double_add {m n : FreeMat} (f g : m ‚ü∂ n) :
  ((f + g).double : m+m ‚ü∂ n+n) = f.double + g.double :=
add_monoid_hom.map_add _ _ _

@[simps]
def mul_functor (N : ‚Ñï) : FreeMat ‚•§ FreeMat :=
{ obj := Œª n, N * n,
  map := Œª m n f, mul N f,
  map_id' := Œª n, (free_abelian_group.map_of _ _).trans $ congr_arg _ $
  begin
    dsimp [basic_universal_map.mul, basic_universal_map.id],
    ext i j,
    rw matrix.kronecker_one_one,
    simp only [matrix.one_apply, equiv.apply_eq_iff_eq, eq_self_iff_true],
    split_ifs; refl
  end,
  map_comp' := Œª l m n f g, mul_comp _ _ _ }
.
instance mul_functor.additive (N : ‚Ñï) : (mul_functor N).additive :=
{ map_zero' := Œª m n, add_monoid_hom.map_zero _,
  map_add' := Œª m n f g, add_monoid_hom.map_add _ _ _ }

def one_mul_iso : mul_functor 1 ‚âÖ ùü≠ _ :=
nat_iso.of_components (Œª n,
  { hom := of $ basic_universal_map.one_mul_hom _,
    inv := of $ basic_universal_map.one_mul_inv _,
    hom_inv_id' := (comp_of _ _).trans $ congr_arg _ $ basic_universal_map.one_mul_inv_hom,
    inv_hom_id' := (comp_of _ _).trans $ congr_arg _ $ basic_universal_map.one_mul_hom_inv })
begin
  intros m n f,
  dsimp,
  show universal_map.comp _ _ = universal_map.comp _ _,
  rw [‚Üê add_monoid_hom.comp_apply, ‚Üê add_monoid_hom.comp_hom_apply_apply,
    ‚Üê add_monoid_hom.flip_apply _ f],
  congr' 1, clear f, ext1 f,
  dsimp,
  simp only [comp_of, mul_of, basic_universal_map.comp, add_monoid_hom.coe_mk',
    basic_universal_map.mul, basic_universal_map.one_mul_hom],
  have : f = matrix.reindex_linear_equiv
     ((equiv.prod_congr_left (Œª _, fin_one_equiv)).trans (equiv.punit_prod (fin n)))
     ((equiv.prod_congr_left (Œª _, fin_one_equiv)).trans (equiv.punit_prod (fin m)))
     (matrix.kronecker 1 f),
  { ext i j, dsimp [matrix.kronecker, matrix.one_apply, equiv.prod_congr_left],
    simp only [one_mul, if_true, eq_iff_true_of_subsingleton], },
  conv_rhs { rw this },
  simp only [matrix.reindex_linear_equiv_mul_reindex_linear_equiv, matrix.one_mul, matrix.mul_one],
end

end FreeMat

/-- Roughly speaking, this is a collection of formal finite sums of matrices
that encode the data that rolls out of the Breen--Deligne resolution. -/
@[derive [small_category, preadditive]]
def data := chain_complex ‚Ñï FreeMat

namespace data

variable (BD : data)

section reindex

open category_theory.limits

/-
=== jmc: I don't think that `reindex` is actually useful
-/

@[simps]
def reindex (rank : ‚Ñï ‚Üí ‚Ñï) (hr : ‚àÄ i, BD.X i = rank i) :
  data :=
{ X := rank,
  d := Œª i j, (eq_to_iso (hr i)).inv ‚â´ BD.d i j ‚â´ (eq_to_iso (hr j)).hom,
  d_comp_d := Œª i j k,
  by simp only [category.assoc, iso.hom_inv_id_assoc, BD.d_comp_d_assoc, zero_comp, comp_zero],
  d_eq_zero := Œª i j hij,
  by simp only [BD.d_eq_zero hij, zero_comp, comp_zero] }

@[simps]
def reindex_iso (rank : ‚Ñï ‚Üí ‚Ñï) (hr : ‚àÄ i, BD.X i = rank i) :
  BD ‚âÖ BD.reindex rank hr :=
differential_object.complex_like.iso_of_components (Œª i, eq_to_iso (hr i)) $
by { intros i j, rw [reindex_d, iso.hom_inv_id_assoc] }

end reindex

section mul

open universal_map

@[simps]
def mul (N : ‚Ñï) : data ‚•§ data :=
(FreeMat.mul_functor N).map_complex_like

def mul_one_iso : (mul 1).obj BD ‚âÖ BD :=
differential_object.complex_like.iso_of_components (Œª i, FreeMat.one_mul_iso.app _) $
Œª i j, FreeMat.one_mul_iso.hom.naturality (BD.d i j)

end mul

/-- `BD.double` is the Breen--Deligne data whose `n`-th rank is `2 * BD.rank n`. -/
@[simps] def double : data :=
{ X := Œª n, BD.X n + BD.X n,
  d := Œª m n, (BD.d m n).double,
  d_eq_zero := Œª m n h, by { rw [BD.d_eq_zero h, universal_map.double_zero] },
  d_comp_d := Œª l m n,
    calc _ = (BD.d l m ‚â´ BD.d m n).double : universal_map.comp_double_double _ _
    ... = 0 : by { rw [BD.d_comp_d, universal_map.double_zero] } }

/-- `BD.pow N` is the Breen--Deligne data whose `n`-th rank is `2^N * BD.rank n`. -/
def pow : ‚Ñï ‚Üí data
| 0     := BD
| (n+1) := (pow n).double

/-- `BD.pow N` is the Breen--Deligne data whose `n`-th rank is `2^N * BD.rank n`. -/
def pow' : ‚Ñï ‚Üí data
| 0     := BD
| (n+1) := (mul 2).obj (pow' n)

lemma BD_pow_X : ‚àÄ N i, (BD.pow N).X i = 2^N * BD.X i
| 0     i := by { rw [pow_zero, one_mul], refl }
| (N+1) i := by { rw [pow_succ, two_mul, add_mul, ‚Üê BD_pow_X N], refl }

@[simps] def œÉ : BD.double ‚ü∂ BD :=
{ f := Œª n, universal_map.œÉ _,
  comm := Œª m n, universal_map.œÉ_comp_double _ }

@[simps] def œÄ : BD.double ‚ü∂ BD :=
{ f := Œª n, universal_map.œÄ _,
  comm := Œª m n, universal_map.œÄ_comp_double _ }

def sum (BD : data) (N : ‚Ñï) : (mul N).obj BD ‚ü∂ BD :=
{ f := Œª n, universal_map.sum _ _,
  comm := Œª m n, universal_map.sum_comp_mul _ _ }

def proj (BD : data) (N : ‚Ñï) : (mul N).obj BD ‚ü∂ BD :=
{ f := Œª n, universal_map.proj _ _,
  comm := Œª m n, universal_map.proj_comp_mul _ _ }

open differential_object.complex_like FreeMat

@[simps]
def hom_double {BD‚ÇÅ BD‚ÇÇ : data} (f : BD‚ÇÅ ‚ü∂ BD‚ÇÇ) : BD‚ÇÅ.double ‚ü∂ BD‚ÇÇ.double :=
{ f := Œª i, (f.f i).double,
  comm := Œª i j,
  calc BD‚ÇÅ.double.d i j ‚â´ (f.f j).double
      = (BD‚ÇÅ.d i j ‚â´ f.f j).double : double_comp_double _ _
  ... = (f.f i ‚â´ BD‚ÇÇ.d i j).double : congr_arg _ (f.comm i j)
  ... = (f.f i).double ‚â´ BD‚ÇÇ.double.d i j : (double_comp_double _ _).symm }

def hom_pow {BD : data} (f : BD.double ‚ü∂ BD) : Œ† N, BD.pow N ‚ü∂ BD
| 0     := ùüô _
| (n+1) := hom_double (hom_pow n) ‚â´ f

def hom_pow' {BD : data} (f : (mul 2).obj BD ‚ü∂ BD) : Œ† N, BD.pow' N ‚ü∂ BD
| 0     := ùüô _
| (n+1) := (mul 2).map (hom_pow' n) ‚â´ f

@[simps]
def homotopy_double {BD‚ÇÅ BD‚ÇÇ : data} {f g : BD‚ÇÅ ‚ü∂ BD‚ÇÇ} (h : homotopy f g) :
  homotopy (hom_double f) (hom_double g) :=
{ h := Œª j i, (h.h j i).double,
  h_eq_zero := Œª i j hij, by rw [h.h_eq_zero i j hij, universal_map.double_zero],
  comm := Œª i j k hij hjk,
  begin
    simp only [double_d, double_comp_double, ‚Üê double_add, h.comm i j k hij hjk],
    exact add_monoid_hom.map_sub _ _ _
  end }

@[simps]
def homotopy_two_mul {BD‚ÇÅ BD‚ÇÇ : data} {f g : BD‚ÇÅ ‚ü∂ BD‚ÇÇ} (h : homotopy f g) :
  homotopy ((mul 2).map f) ((mul 2).map g) :=
{ h := Œª j i, universal_map.mul 2 (h.h j i),
  h_eq_zero := Œª i j hij, by rw [h.h_eq_zero i j hij, add_monoid_hom.map_zero],
  comm := Œª i j k hij hjk,
  begin
    simp only [mul_obj_d, mul_map_f, ‚Üê add_monoid_hom.map_sub],
    rw [‚Üê h.comm i j k hij hjk, add_monoid_hom.map_add],
    erw [universal_map.mul_comp, universal_map.mul_comp],
    refl
  end }

def homotopy_pow (h : homotopy BD.œÉ BD.œÄ) :
  Œ† N, homotopy (hom_pow BD.œÉ N) (hom_pow BD.œÄ N)
| 0     := homotopy.refl
| (n+1) := (homotopy_double (homotopy_pow n)).comp h

def homotopy_pow' (h : homotopy (BD.sum 2) (BD.proj 2)) :
  Œ† N, homotopy (hom_pow' (BD.sum 2) N) (hom_pow' (BD.proj 2) N)
| 0     := homotopy.refl
| (N+1) := (homotopy_two_mul (homotopy_pow' N)).comp h

def pow'_iso_mul : Œ† N, BD.pow' N ‚âÖ (mul (2^N)).obj BD
| 0     := BD.mul_one_iso.symm
| (N+1) := show (mul 2).obj (BD.pow' N) ‚âÖ (mul (2 * 2 ^ N)).obj BD, from sorry

lemma hom_pow'_sum : ‚àÄ N, (BD.pow'_iso_mul N).inv ‚â´ hom_pow' (BD.sum 2) N = BD.sum (2^N)
| 0     := by { ext i : 2, simp only [hom_pow', category.comp_id], sorry }
| (N+1) := sorry

lemma hom_pow'_proj : ‚àÄ N, (BD.pow'_iso_mul N).inv ‚â´ hom_pow' (BD.proj 2) N = BD.proj (2^N)
| 0     := sorry
| (N+1) := sorry

def homotopy_mul (h : homotopy (BD.sum 2) (BD.proj 2)) (N : ‚Ñï) :
  homotopy (BD.sum (2^N)) (BD.proj (2^N)) :=
(homotopy.of_eq $ BD.hom_pow'_sum N).symm.trans $
  ((BD.homotopy_pow' h N).const_comp (BD.pow'_iso_mul N).inv).trans $
  (homotopy.of_eq $ BD.hom_pow'_proj N)

end data

section
universe variables u
open universal_map
variables {m n : ‚Ñï} (A : Type u) [add_comm_group A] (f : universal_map m n)

end

open differential_object.complex_like

/-- A Breen--Deligne `package` consists of Breen--Deligne `data`
that forms a complex, together with a `homotopy`
between the two universal maps `œÉ_add` and `œÉ_proj`. -/
structure package :=
(data       : data)
(homotopy   : homotopy (data.sum 2) (data.proj 2))

namespace package

/-- `BD.rank i` is the rank of the `i`th entry in the Breen--Deligne resolution described by `BD`. -/
def rank (BD : package) := BD.data.X

def map (BD : package) (i : ‚Ñï) := BD.data.d (i+1) i

@[simp] lemma map_comp_map (BD : package) (i : ‚Ñï) : BD.map _ ‚â´ BD.map i = 0 :=
BD.data.d_comp_d _ _ _

end package

end breen_deligne
